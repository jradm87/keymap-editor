{"ast":null,"code":"/*\r\n  fuzzysort.js https://github.com/farzher/fuzzysort\r\n  SublimeText-like Fuzzy Search\r\n\r\n  fuzzysort.single('fs', 'Fuzzy Search') // {score: -16}\r\n  fuzzysort.single('test', 'test') // {score: 0}\r\n  fuzzysort.single('doesnt exist', 'target') // null\r\n\r\n  fuzzysort.go('mr', [{file:'Monitor.cpp'}, {file:'MeshRenderer.cpp'}], {key:'file'})\r\n  // [{score:-18, obj:{file:'MeshRenderer.cpp'}}, {score:-6009, obj:{file:'Monitor.cpp'}}]\r\n\r\n  fuzzysort.go('mr', ['Monitor.cpp', 'MeshRenderer.cpp'])\r\n  // [{score: -18, target: \"MeshRenderer.cpp\"}, {score: -6009, target: \"Monitor.cpp\"}]\r\n\r\n  fuzzysort.highlight(fuzzysort.single('fs', 'Fuzzy Search'), '<b>', '</b>')\r\n  // <b>F</b>uzzy <b>S</b>earch\r\n*/\n// UMD (Universal Module Definition) for fuzzysort\n;\n\n(function (root, UMD) {\n  if (typeof define === 'function' && define.amd) define([], UMD);else if (typeof module === 'object' && module.exports) module.exports = UMD();else root.fuzzysort = UMD();\n})(this, function UMD() {\n  function fuzzysortNew(instanceOptions) {\n    var fuzzysort = {\n      single: function single(search, target, options) {\n        ;\n        if (search == 'farzher') return {\n          target: \"farzher was here (^-^*)/\",\n          score: 0,\n          indexes: [0, 1, 2, 3, 4, 5, 6]\n        };\n        if (!search) return null;\n        if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);\n        if (!target) return null;\n        if (!isObj(target)) target = fuzzysort.getPrepared(target);\n        var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n        return algorithm(search, target, search[0]);\n      },\n      go: function go(search, targets, options) {\n        ;\n        if (search == 'farzher') return [{\n          target: \"farzher was here (^-^*)/\",\n          score: 0,\n          indexes: [0, 1, 2, 3, 4, 5, 6],\n          obj: targets ? targets[0] : null\n        }];\n        if (!search) return noResults;\n        search = fuzzysort.prepareSearch(search);\n        var searchLowerCode = search[0];\n        var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n        var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n        var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n        var resultsLen = 0;\n        var limitedCount = 0;\n        var targetsLen = targets.length; // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n        // options.keys\n\n        if (options && options.keys) {\n          var scoreFn = options.scoreFn || defaultScoreFn;\n          var keys = options.keys;\n          var keysLen = keys.length;\n\n          for (var i = targetsLen - 1; i >= 0; --i) {\n            var obj = targets[i];\n            var objResults = new Array(keysLen);\n\n            for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n              var key = keys[keyI];\n              var target = getValue(obj, key);\n\n              if (!target) {\n                objResults[keyI] = null;\n                continue;\n              }\n\n              if (!isObj(target)) target = fuzzysort.getPrepared(target);\n              objResults[keyI] = algorithm(search, target, searchLowerCode);\n            }\n\n            objResults.obj = obj; // before scoreFn so scoreFn can use it\n\n            var score = scoreFn(objResults);\n            if (score === null) continue;\n            if (score < threshold) continue;\n            objResults.score = score;\n\n            if (resultsLen < limit) {\n              q.add(objResults);\n              ++resultsLen;\n            } else {\n              ++limitedCount;\n              if (score > q.peek().score) q.replaceTop(objResults);\n            }\n          } // options.key\n\n        } else if (options && options.key) {\n          var key = options.key;\n\n          for (var i = targetsLen - 1; i >= 0; --i) {\n            var obj = targets[i];\n            var target = getValue(obj, key);\n            if (!target) continue;\n            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n            var result = algorithm(search, target, searchLowerCode);\n            if (result === null) continue;\n            if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj\n\n            result = {\n              target: result.target,\n              _targetLowerCodes: null,\n              _nextBeginningIndexes: null,\n              score: result.score,\n              indexes: result.indexes,\n              obj: obj\n            }; // hidden\n\n            if (resultsLen < limit) {\n              q.add(result);\n              ++resultsLen;\n            } else {\n              ++limitedCount;\n              if (result.score > q.peek().score) q.replaceTop(result);\n            }\n          } // no keys\n\n        } else {\n          for (var i = targetsLen - 1; i >= 0; --i) {\n            var target = targets[i];\n            if (!target) continue;\n            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n            var result = algorithm(search, target, searchLowerCode);\n            if (result === null) continue;\n            if (result.score < threshold) continue;\n\n            if (resultsLen < limit) {\n              q.add(result);\n              ++resultsLen;\n            } else {\n              ++limitedCount;\n              if (result.score > q.peek().score) q.replaceTop(result);\n            }\n          }\n        }\n\n        if (resultsLen === 0) return noResults;\n        var results = new Array(resultsLen);\n\n        for (var i = resultsLen - 1; i >= 0; --i) {\n          results[i] = q.poll();\n        }\n\n        results.total = resultsLen + limitedCount;\n        return results;\n      },\n      goAsync: function goAsync(search, targets, options) {\n        var canceled = false;\n        var p = new Promise(function (resolve, reject) {\n          ;\n          if (search == 'farzher') return resolve([{\n            target: \"farzher was here (^-^*)/\",\n            score: 0,\n            indexes: [0, 1, 2, 3, 4, 5, 6],\n            obj: targets ? targets[0] : null\n          }]);\n          if (!search) return resolve(noResults);\n          search = fuzzysort.prepareSearch(search);\n          var searchLowerCode = search[0];\n          var q = fastpriorityqueue();\n          var iCurrent = targets.length - 1;\n          var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n          var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n          var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n          var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n          var resultsLen = 0;\n          var limitedCount = 0;\n\n          function step() {\n            if (canceled) return reject('canceled');\n            var startMs = Date.now(); // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n            // options.keys\n\n            if (options && options.keys) {\n              var scoreFn = options.scoreFn || defaultScoreFn;\n              var keys = options.keys;\n              var keysLen = keys.length;\n\n              for (; iCurrent >= 0; --iCurrent) {\n                if (iCurrent % 1000\n                /*itemsPerCheck*/\n                === 0) {\n                  if (Date.now() - startMs >= 10\n                  /*asyncInterval*/\n                  ) {\n                    isNode ? setImmediate(step) : setTimeout(step);\n                    return;\n                  }\n                }\n\n                var obj = targets[iCurrent];\n                var objResults = new Array(keysLen);\n\n                for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                  var key = keys[keyI];\n                  var target = getValue(obj, key);\n\n                  if (!target) {\n                    objResults[keyI] = null;\n                    continue;\n                  }\n\n                  if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                  objResults[keyI] = algorithm(search, target, searchLowerCode);\n                }\n\n                objResults.obj = obj; // before scoreFn so scoreFn can use it\n\n                var score = scoreFn(objResults);\n                if (score === null) continue;\n                if (score < threshold) continue;\n                objResults.score = score;\n\n                if (resultsLen < limit) {\n                  q.add(objResults);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (score > q.peek().score) q.replaceTop(objResults);\n                }\n              } // options.key\n\n            } else if (options && options.key) {\n              var key = options.key;\n\n              for (; iCurrent >= 0; --iCurrent) {\n                if (iCurrent % 1000\n                /*itemsPerCheck*/\n                === 0) {\n                  if (Date.now() - startMs >= 10\n                  /*asyncInterval*/\n                  ) {\n                    isNode ? setImmediate(step) : setTimeout(step);\n                    return;\n                  }\n                }\n\n                var obj = targets[iCurrent];\n                var target = getValue(obj, key);\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj\n\n                result = {\n                  target: result.target,\n                  _targetLowerCodes: null,\n                  _nextBeginningIndexes: null,\n                  score: result.score,\n                  indexes: result.indexes,\n                  obj: obj\n                }; // hidden\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              } // no keys\n\n            } else {\n              for (; iCurrent >= 0; --iCurrent) {\n                if (iCurrent % 1000\n                /*itemsPerCheck*/\n                === 0) {\n                  if (Date.now() - startMs >= 10\n                  /*asyncInterval*/\n                  ) {\n                    isNode ? setImmediate(step) : setTimeout(step);\n                    return;\n                  }\n                }\n\n                var target = targets[iCurrent];\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue;\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              }\n            }\n\n            if (resultsLen === 0) return resolve(noResults);\n            var results = new Array(resultsLen);\n\n            for (var i = resultsLen - 1; i >= 0; --i) {\n              results[i] = q.poll();\n            }\n\n            results.total = resultsLen + limitedCount;\n            resolve(results);\n          }\n\n          isNode ? setImmediate(step) : step(); //setTimeout here is too slow\n        });\n\n        p.cancel = function () {\n          canceled = true;\n        };\n\n        return p;\n      },\n      highlight: function highlight(result, hOpen, hClose) {\n        if (typeof hOpen == 'function') return fuzzysort.highlightCallback(result, hOpen);\n        if (result === null) return null;\n        if (hOpen === undefined) hOpen = '<b>';\n        if (hClose === undefined) hClose = '</b>';\n        var highlighted = '';\n        var matchesIndex = 0;\n        var opened = false;\n        var target = result.target;\n        var targetLen = target.length;\n        var matchesBest = result.indexes;\n\n        for (var i = 0; i < targetLen; ++i) {\n          var char = target[i];\n\n          if (matchesBest[matchesIndex] === i) {\n            ++matchesIndex;\n\n            if (!opened) {\n              opened = true;\n              highlighted += hOpen;\n            }\n\n            if (matchesIndex === matchesBest.length) {\n              highlighted += char + hClose + target.substr(i + 1);\n              break;\n            }\n          } else {\n            if (opened) {\n              opened = false;\n              highlighted += hClose;\n            }\n          }\n\n          highlighted += char;\n        }\n\n        return highlighted;\n      },\n      highlightCallback: function highlightCallback(result, cb) {\n        if (result === null) return null;\n        var target = result.target;\n        var targetLen = target.length;\n        var indexes = result.indexes;\n        var highlighted = '';\n        var matchI = 0;\n        var indexesI = 0;\n        var opened = false;\n        var result = [];\n\n        for (var i = 0; i < targetLen; ++i) {\n          var char = target[i];\n\n          if (indexes[indexesI] === i) {\n            ++indexesI;\n\n            if (!opened) {\n              opened = true;\n              result.push(highlighted);\n              highlighted = '';\n            }\n\n            if (indexesI === indexes.length) {\n              highlighted += char;\n              result.push(cb(highlighted, matchI++));\n              highlighted = '';\n              result.push(target.substr(i + 1));\n              break;\n            }\n          } else {\n            if (opened) {\n              opened = false;\n              result.push(cb(highlighted, matchI++));\n              highlighted = '';\n            }\n          }\n\n          highlighted += char;\n        }\n\n        return result;\n      },\n      prepare: function prepare(target) {\n        if (!target) return {\n          target: '',\n          _targetLowerCodes: [0\n          /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/\n          ],\n          _nextBeginningIndexes: null,\n          score: null,\n          indexes: null,\n          obj: null\n        }; // hidden\n\n        return {\n          target: target,\n          _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n          _nextBeginningIndexes: null,\n          score: null,\n          indexes: null,\n          obj: null\n        }; // hidden\n      },\n      prepareSlow: function prepareSlow(target) {\n        if (!target) return {\n          target: '',\n          _targetLowerCodes: [0\n          /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/\n          ],\n          _nextBeginningIndexes: null,\n          score: null,\n          indexes: null,\n          obj: null\n        }; // hidden\n\n        return {\n          target: target,\n          _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n          _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),\n          score: null,\n          indexes: null,\n          obj: null\n        }; // hidden\n      },\n      prepareSearch: function prepareSearch(search) {\n        if (!search) search = '';\n        return fuzzysort.prepareLowerCodes(search);\n      },\n      // Below this point is only internal code\n      // Below this point is only internal code\n      // Below this point is only internal code\n      // Below this point is only internal code\n      getPrepared: function getPrepared(target) {\n        if (target.length > 999) return fuzzysort.prepare(target); // don't cache huge targets\n\n        var targetPrepared = preparedCache.get(target);\n        if (targetPrepared !== undefined) return targetPrepared;\n        targetPrepared = fuzzysort.prepare(target);\n        preparedCache.set(target, targetPrepared);\n        return targetPrepared;\n      },\n      getPreparedSearch: function getPreparedSearch(search) {\n        if (search.length > 999) return fuzzysort.prepareSearch(search); // don't cache huge searches\n\n        var searchPrepared = preparedSearchCache.get(search);\n        if (searchPrepared !== undefined) return searchPrepared;\n        searchPrepared = fuzzysort.prepareSearch(search);\n        preparedSearchCache.set(search, searchPrepared);\n        return searchPrepared;\n      },\n      algorithm: function algorithm(searchLowerCodes, prepared, searchLowerCode) {\n        var targetLowerCodes = prepared._targetLowerCodes;\n        var searchLen = searchLowerCodes.length;\n        var targetLen = targetLowerCodes.length;\n        var searchI = 0; // where we at\n\n        var targetI = 0; // where you at\n\n        var typoSimpleI = 0;\n        var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!\n        // walk through target. find sequential matches.\n        // if all chars aren't found then exit\n\n        for (;;) {\n          var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\n          if (isMatch) {\n            matchesSimple[matchesSimpleLen++] = targetI;\n            ++searchI;\n            if (searchI === searchLen) break;\n            searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];\n          }\n\n          ++targetI;\n\n          if (targetI >= targetLen) {\n            // Failed to find searchI\n            // Check for typo or exit\n            // we go as far as possible before trying to transpose\n            // then we transpose backwards until we reach the beginning\n            for (;;) {\n              if (searchI <= 1) return null; // not allowed to transpose first char\n\n              if (typoSimpleI === 0) {\n                // we haven't tried to transpose yet\n                --searchI;\n                var searchLowerCodeNew = searchLowerCodes[searchI];\n                if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n\n                typoSimpleI = searchI;\n              } else {\n                if (typoSimpleI === 1) return null; // reached the end of the line for transposing\n\n                --typoSimpleI;\n                searchI = typoSimpleI;\n                searchLowerCode = searchLowerCodes[searchI + 1];\n                var searchLowerCodeNew = searchLowerCodes[searchI];\n                if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n              }\n\n              matchesSimpleLen = searchI;\n              targetI = matchesSimple[matchesSimpleLen - 1] + 1;\n              break;\n            }\n          }\n        }\n\n        var searchI = 0;\n        var typoStrictI = 0;\n        var successStrict = false;\n        var matchesStrictLen = 0;\n        var nextBeginningIndexes = prepared._nextBeginningIndexes;\n        if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n        var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!\n        // Let's try a more advanced and strict test to improve the score\n        // only count it as a match if it's consecutive or a beginning character!\n\n        if (targetI !== targetLen) for (;;) {\n          if (targetI >= targetLen) {\n            // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n            if (searchI <= 0) {\n              // We failed to push chars forward for a better match\n              // transpose, starting from the beginning\n              ++typoStrictI;\n              if (typoStrictI > searchLen - 2) break;\n              if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn't make sense to transpose a repeat char\n\n              targetI = firstPossibleI;\n              continue;\n            }\n\n            --searchI;\n            var lastMatch = matchesStrict[--matchesStrictLen];\n            targetI = nextBeginningIndexes[lastMatch];\n          } else {\n            var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];\n\n            if (isMatch) {\n              matchesStrict[matchesStrictLen++] = targetI;\n              ++searchI;\n\n              if (searchI === searchLen) {\n                successStrict = true;\n                break;\n              }\n\n              ++targetI;\n            } else {\n              targetI = nextBeginningIndexes[targetI];\n            }\n          }\n        }\n        {\n          // tally up the score & keep track of matches for highlighting later\n          if (successStrict) {\n            var matchesBest = matchesStrict;\n            var matchesBestLen = matchesStrictLen;\n          } else {\n            var matchesBest = matchesSimple;\n            var matchesBestLen = matchesSimpleLen;\n          }\n\n          var score = 0;\n          var lastTargetI = -1;\n\n          for (var i = 0; i < searchLen; ++i) {\n            var targetI = matchesBest[i]; // score only goes down if they're not consecutive\n\n            if (lastTargetI !== targetI - 1) score -= targetI;\n            lastTargetI = targetI;\n          }\n\n          if (!successStrict) {\n            score *= 1000;\n            if (typoSimpleI !== 0) score += -20;\n            /*typoPenalty*/\n          } else {\n            if (typoStrictI !== 0) score += -20;\n            /*typoPenalty*/\n          }\n\n          score -= targetLen - searchLen;\n          prepared.score = score;\n          prepared.indexes = new Array(matchesBestLen);\n\n          for (var i = matchesBestLen - 1; i >= 0; --i) {\n            prepared.indexes[i] = matchesBest[i];\n          }\n\n          return prepared;\n        }\n      },\n      algorithmNoTypo: function algorithmNoTypo(searchLowerCodes, prepared, searchLowerCode) {\n        var targetLowerCodes = prepared._targetLowerCodes;\n        var searchLen = searchLowerCodes.length;\n        var targetLen = targetLowerCodes.length;\n        var searchI = 0; // where we at\n\n        var targetI = 0; // where you at\n\n        var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!\n        // walk through target. find sequential matches.\n        // if all chars aren't found then exit\n\n        for (;;) {\n          var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\n          if (isMatch) {\n            matchesSimple[matchesSimpleLen++] = targetI;\n            ++searchI;\n            if (searchI === searchLen) break;\n            searchLowerCode = searchLowerCodes[searchI];\n          }\n\n          ++targetI;\n          if (targetI >= targetLen) return null; // Failed to find searchI\n        }\n\n        var searchI = 0;\n        var successStrict = false;\n        var matchesStrictLen = 0;\n        var nextBeginningIndexes = prepared._nextBeginningIndexes;\n        if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n        var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!\n        // Let's try a more advanced and strict test to improve the score\n        // only count it as a match if it's consecutive or a beginning character!\n\n        if (targetI !== targetLen) for (;;) {\n          if (targetI >= targetLen) {\n            // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n            if (searchI <= 0) break; // We failed to push chars forward for a better match\n\n            --searchI;\n            var lastMatch = matchesStrict[--matchesStrictLen];\n            targetI = nextBeginningIndexes[lastMatch];\n          } else {\n            var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n\n            if (isMatch) {\n              matchesStrict[matchesStrictLen++] = targetI;\n              ++searchI;\n\n              if (searchI === searchLen) {\n                successStrict = true;\n                break;\n              }\n\n              ++targetI;\n            } else {\n              targetI = nextBeginningIndexes[targetI];\n            }\n          }\n        }\n        {\n          // tally up the score & keep track of matches for highlighting later\n          if (successStrict) {\n            var matchesBest = matchesStrict;\n            var matchesBestLen = matchesStrictLen;\n          } else {\n            var matchesBest = matchesSimple;\n            var matchesBestLen = matchesSimpleLen;\n          }\n\n          var score = 0;\n          var lastTargetI = -1;\n\n          for (var i = 0; i < searchLen; ++i) {\n            var targetI = matchesBest[i]; // score only goes down if they're not consecutive\n\n            if (lastTargetI !== targetI - 1) score -= targetI;\n            lastTargetI = targetI;\n          }\n\n          if (!successStrict) score *= 1000;\n          score -= targetLen - searchLen;\n          prepared.score = score;\n          prepared.indexes = new Array(matchesBestLen);\n\n          for (var i = matchesBestLen - 1; i >= 0; --i) {\n            prepared.indexes[i] = matchesBest[i];\n          }\n\n          return prepared;\n        }\n      },\n      prepareLowerCodes: function prepareLowerCodes(str) {\n        var strLen = str.length;\n        var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n\n        var lower = str.toLowerCase();\n\n        for (var i = 0; i < strLen; ++i) {\n          lowerCodes[i] = lower.charCodeAt(i);\n        }\n\n        return lowerCodes;\n      },\n      prepareBeginningIndexes: function prepareBeginningIndexes(target) {\n        var targetLen = target.length;\n        var beginningIndexes = [];\n        var beginningIndexesLen = 0;\n        var wasUpper = false;\n        var wasAlphanum = false;\n\n        for (var i = 0; i < targetLen; ++i) {\n          var targetCode = target.charCodeAt(i);\n          var isUpper = targetCode >= 65 && targetCode <= 90;\n          var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n          var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n          wasUpper = isUpper;\n          wasAlphanum = isAlphanum;\n          if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n        }\n\n        return beginningIndexes;\n      },\n      prepareNextBeginningIndexes: function prepareNextBeginningIndexes(target) {\n        var targetLen = target.length;\n        var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);\n        var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n\n        var lastIsBeginning = beginningIndexes[0];\n        var lastIsBeginningI = 0;\n\n        for (var i = 0; i < targetLen; ++i) {\n          if (lastIsBeginning > i) {\n            nextBeginningIndexes[i] = lastIsBeginning;\n          } else {\n            lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n            nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n          }\n        }\n\n        return nextBeginningIndexes;\n      },\n      cleanup: cleanup,\n      new: fuzzysortNew\n    };\n    return fuzzysort;\n  } // fuzzysortNew\n  // This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\n\n\n  var isNode = typeof require !== 'undefined' && typeof window === 'undefined';\n  var MyMap = typeof Map === 'function' ? Map : function () {\n    var s = Object.create(null);\n\n    this.get = function (k) {\n      return s[k];\n    };\n\n    this.set = function (k, val) {\n      s[k] = val;\n      return this;\n    };\n\n    this.clear = function () {\n      s = Object.create(null);\n    };\n  };\n  var preparedCache = new MyMap();\n  var preparedSearchCache = new MyMap();\n  var noResults = [];\n  noResults.total = 0;\n  var matchesSimple = [];\n  var matchesStrict = [];\n\n  function cleanup() {\n    preparedCache.clear();\n    preparedSearchCache.clear();\n    matchesSimple = [];\n    matchesStrict = [];\n  }\n\n  function defaultScoreFn(a) {\n    var max = -9007199254740991;\n\n    for (var i = a.length - 1; i >= 0; --i) {\n      var result = a[i];\n      if (result === null) continue;\n      var score = result.score;\n      if (score > max) max = score;\n    }\n\n    if (max === -9007199254740991) return null;\n    return max;\n  } // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n  // prop = 'key1.key2'        10ms\n  // prop = ['key1', 'key2']   27ms\n\n\n  function getValue(obj, prop) {\n    var tmp = obj[prop];\n    if (tmp !== undefined) return tmp;\n    var segs = prop;\n    if (!Array.isArray(prop)) segs = prop.split('.');\n    var len = segs.length;\n    var i = -1;\n\n    while (obj && ++i < len) {\n      obj = obj[segs[i]];\n    }\n\n    return obj;\n  }\n\n  function isObj(x) {\n    return typeof x === 'object';\n  } // faster as a function\n  // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n\n\n  var fastpriorityqueue = function fastpriorityqueue() {\n    var r = [],\n        o = 0,\n        e = {};\n\n    function n() {\n      for (var e = 0, n = r[e], c = 1; c < o;) {\n        var f = c + 1;\n        e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);\n      }\n\n      for (var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1) {\n        r[e] = r[a];\n      }\n\n      r[e] = n;\n    }\n\n    return e.add = function (e) {\n      var n = o;\n      r[o++] = e;\n\n      for (var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1) {\n        r[n] = r[c];\n      }\n\n      r[n] = e;\n    }, e.poll = function () {\n      if (0 !== o) {\n        var e = r[0];\n        return r[0] = r[--o], n(), e;\n      }\n    }, e.peek = function (e) {\n      if (0 !== o) return r[0];\n    }, e.replaceTop = function (o) {\n      r[0] = o, n();\n    }, e;\n  };\n\n  var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own\n\n  return fuzzysortNew();\n}); // UMD\n// TODO: (performance) wasm version!?\n// TODO: (performance) threads?\n// TODO: (performance) avoid cache misses\n// TODO: (performance) preparedCache is a memory leak\n// TODO: (like sublime) backslash === forwardslash\n// TODO: (like sublime) spaces: \"a b\" should do 2 searches 1 for a and 1 for b\n// TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\n// TODO: (performance) idk if allowTypo is optimized","map":{"version":3,"names":["root","UMD","define","amd","module","exports","fuzzysort","fuzzysortNew","instanceOptions","single","search","target","options","score","indexes","isObj","getPreparedSearch","getPrepared","allowTypo","undefined","algorithm","algorithmNoTypo","go","targets","obj","noResults","prepareSearch","searchLowerCode","threshold","limit","resultsLen","limitedCount","targetsLen","length","keys","scoreFn","defaultScoreFn","keysLen","i","objResults","Array","keyI","key","getValue","q","add","peek","replaceTop","result","_targetLowerCodes","_nextBeginningIndexes","results","poll","total","goAsync","canceled","p","Promise","resolve","reject","fastpriorityqueue","iCurrent","step","startMs","Date","now","isNode","setImmediate","setTimeout","cancel","highlight","hOpen","hClose","highlightCallback","highlighted","matchesIndex","opened","targetLen","matchesBest","char","substr","cb","matchI","indexesI","push","prepare","prepareLowerCodes","prepareSlow","prepareNextBeginningIndexes","targetPrepared","preparedCache","get","set","searchPrepared","preparedSearchCache","searchLowerCodes","prepared","targetLowerCodes","searchLen","searchI","targetI","typoSimpleI","matchesSimpleLen","isMatch","matchesSimple","searchLowerCodeNew","typoStrictI","successStrict","matchesStrictLen","nextBeginningIndexes","firstPossibleI","lastMatch","matchesStrict","matchesBestLen","lastTargetI","str","strLen","lowerCodes","lower","toLowerCase","charCodeAt","prepareBeginningIndexes","beginningIndexes","beginningIndexesLen","wasUpper","wasAlphanum","targetCode","isUpper","isAlphanum","isBeginning","lastIsBeginning","lastIsBeginningI","cleanup","new","require","window","MyMap","Map","s","Object","create","k","val","clear","a","max","prop","tmp","segs","isArray","split","len","x","r","o","e","n","c","f"],"sources":["/home/runner/work/keymap-editor/keymap-editor/app/node_modules/fuzzysort/fuzzysort.js"],"sourcesContent":["/*\r\n  fuzzysort.js https://github.com/farzher/fuzzysort\r\n  SublimeText-like Fuzzy Search\r\n\r\n  fuzzysort.single('fs', 'Fuzzy Search') // {score: -16}\r\n  fuzzysort.single('test', 'test') // {score: 0}\r\n  fuzzysort.single('doesnt exist', 'target') // null\r\n\r\n  fuzzysort.go('mr', [{file:'Monitor.cpp'}, {file:'MeshRenderer.cpp'}], {key:'file'})\r\n  // [{score:-18, obj:{file:'MeshRenderer.cpp'}}, {score:-6009, obj:{file:'Monitor.cpp'}}]\r\n\r\n  fuzzysort.go('mr', ['Monitor.cpp', 'MeshRenderer.cpp'])\r\n  // [{score: -18, target: \"MeshRenderer.cpp\"}, {score: -6009, target: \"Monitor.cpp\"}]\r\n\r\n  fuzzysort.highlight(fuzzysort.single('fs', 'Fuzzy Search'), '<b>', '</b>')\r\n  // <b>F</b>uzzy <b>S</b>earch\r\n*/\r\n\r\n// UMD (Universal Module Definition) for fuzzysort\r\n;(function(root, UMD) {\r\n  if(typeof define === 'function' && define.amd) define([], UMD)\r\n  else if(typeof module === 'object' && module.exports) module.exports = UMD()\r\n  else root.fuzzysort = UMD()\r\n})(this, function UMD() { function fuzzysortNew(instanceOptions) {\r\n\r\n  var fuzzysort = {\r\n\r\n    single: function(search, target, options) {                                                                                                                                                                                                               ;if(search=='farzher')return{target:\"farzher was here (^-^*)/\",score:0,indexes:[0,1,2,3,4,5,6]}\r\n      if(!search) return null\r\n      if(!isObj(search)) search = fuzzysort.getPreparedSearch(search)\r\n\r\n      if(!target) return null\r\n      if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n      var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\r\n        : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\r\n        : true\r\n      var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\r\n      return algorithm(search, target, search[0])\r\n    },\r\n\r\n    go: function(search, targets, options) {                                                                                                                                                                                                                  ;if(search=='farzher')return[{target:\"farzher was here (^-^*)/\",score:0,indexes:[0,1,2,3,4,5,6],obj:targets?targets[0]:null}]\r\n      if(!search) return noResults\r\n      search = fuzzysort.prepareSearch(search)\r\n      var searchLowerCode = search[0]\r\n\r\n      var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\r\n      var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991\r\n      var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\r\n        : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\r\n        : true\r\n      var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\r\n      var resultsLen = 0; var limitedCount = 0\r\n      var targetsLen = targets.length\r\n\r\n      // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\r\n\r\n      // options.keys\r\n      if(options && options.keys) {\r\n        var scoreFn = options.scoreFn || defaultScoreFn\r\n        var keys = options.keys\r\n        var keysLen = keys.length\r\n        for(var i = targetsLen - 1; i >= 0; --i) { var obj = targets[i]\r\n          var objResults = new Array(keysLen)\r\n          for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\r\n            var key = keys[keyI]\r\n            var target = getValue(obj, key)\r\n            if(!target) { objResults[keyI] = null; continue }\r\n            if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n            objResults[keyI] = algorithm(search, target, searchLowerCode)\r\n          }\r\n          objResults.obj = obj // before scoreFn so scoreFn can use it\r\n          var score = scoreFn(objResults)\r\n          if(score === null) continue\r\n          if(score < threshold) continue\r\n          objResults.score = score\r\n          if(resultsLen < limit) { q.add(objResults); ++resultsLen }\r\n          else {\r\n            ++limitedCount\r\n            if(score > q.peek().score) q.replaceTop(objResults)\r\n          }\r\n        }\r\n\r\n      // options.key\r\n      } else if(options && options.key) {\r\n        var key = options.key\r\n        for(var i = targetsLen - 1; i >= 0; --i) { var obj = targets[i]\r\n          var target = getValue(obj, key)\r\n          if(!target) continue\r\n          if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n          var result = algorithm(search, target, searchLowerCode)\r\n          if(result === null) continue\r\n          if(result.score < threshold) continue\r\n\r\n          // have to clone result so duplicate targets from different obj can each reference the correct obj\r\n          result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj} // hidden\r\n\r\n          if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n          else {\r\n            ++limitedCount\r\n            if(result.score > q.peek().score) q.replaceTop(result)\r\n          }\r\n        }\r\n\r\n      // no keys\r\n      } else {\r\n        for(var i = targetsLen - 1; i >= 0; --i) { var target = targets[i]\r\n          if(!target) continue\r\n          if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n          var result = algorithm(search, target, searchLowerCode)\r\n          if(result === null) continue\r\n          if(result.score < threshold) continue\r\n          if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n          else {\r\n            ++limitedCount\r\n            if(result.score > q.peek().score) q.replaceTop(result)\r\n          }\r\n        }\r\n      }\r\n\r\n      if(resultsLen === 0) return noResults\r\n      var results = new Array(resultsLen)\r\n      for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\r\n      results.total = resultsLen + limitedCount\r\n      return results\r\n    },\r\n\r\n    goAsync: function(search, targets, options) {\r\n      var canceled = false\r\n      var p = new Promise(function(resolve, reject) {                                                                                                                                                                                                         ;if(search=='farzher')return resolve([{target:\"farzher was here (^-^*)/\",score:0,indexes:[0,1,2,3,4,5,6],obj:targets?targets[0]:null}])\r\n        if(!search) return resolve(noResults)\r\n        search = fuzzysort.prepareSearch(search)\r\n        var searchLowerCode = search[0]\r\n\r\n        var q = fastpriorityqueue()\r\n        var iCurrent = targets.length - 1\r\n        var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\r\n        var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991\r\n        var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\r\n          : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\r\n          : true\r\n        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\r\n        var resultsLen = 0; var limitedCount = 0\r\n        function step() {\r\n          if(canceled) return reject('canceled')\r\n\r\n          var startMs = Date.now()\r\n\r\n          // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\r\n\r\n          // options.keys\r\n          if(options && options.keys) {\r\n            var scoreFn = options.scoreFn || defaultScoreFn\r\n            var keys = options.keys\r\n            var keysLen = keys.length\r\n            for(; iCurrent >= 0; --iCurrent) {\r\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\r\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\r\n                  isNode?setImmediate(step):setTimeout(step)\r\n                  return\r\n                }\r\n              }\r\n\r\n              var obj = targets[iCurrent]\r\n              var objResults = new Array(keysLen)\r\n              for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\r\n                var key = keys[keyI]\r\n                var target = getValue(obj, key)\r\n                if(!target) { objResults[keyI] = null; continue }\r\n                if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n                objResults[keyI] = algorithm(search, target, searchLowerCode)\r\n              }\r\n              objResults.obj = obj // before scoreFn so scoreFn can use it\r\n              var score = scoreFn(objResults)\r\n              if(score === null) continue\r\n              if(score < threshold) continue\r\n              objResults.score = score\r\n              if(resultsLen < limit) { q.add(objResults); ++resultsLen }\r\n              else {\r\n                ++limitedCount\r\n                if(score > q.peek().score) q.replaceTop(objResults)\r\n              }\r\n            }\r\n\r\n          // options.key\r\n          } else if(options && options.key) {\r\n            var key = options.key\r\n            for(; iCurrent >= 0; --iCurrent) {\r\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\r\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\r\n                  isNode?setImmediate(step):setTimeout(step)\r\n                  return\r\n                }\r\n              }\r\n\r\n              var obj = targets[iCurrent]\r\n              var target = getValue(obj, key)\r\n              if(!target) continue\r\n              if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n              var result = algorithm(search, target, searchLowerCode)\r\n              if(result === null) continue\r\n              if(result.score < threshold) continue\r\n\r\n              // have to clone result so duplicate targets from different obj can each reference the correct obj\r\n              result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj} // hidden\r\n\r\n              if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n              else {\r\n                ++limitedCount\r\n                if(result.score > q.peek().score) q.replaceTop(result)\r\n              }\r\n            }\r\n\r\n          // no keys\r\n          } else {\r\n            for(; iCurrent >= 0; --iCurrent) {\r\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\r\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\r\n                  isNode?setImmediate(step):setTimeout(step)\r\n                  return\r\n                }\r\n              }\r\n\r\n              var target = targets[iCurrent]\r\n              if(!target) continue\r\n              if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n              var result = algorithm(search, target, searchLowerCode)\r\n              if(result === null) continue\r\n              if(result.score < threshold) continue\r\n              if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n              else {\r\n                ++limitedCount\r\n                if(result.score > q.peek().score) q.replaceTop(result)\r\n              }\r\n            }\r\n          }\r\n\r\n          if(resultsLen === 0) return resolve(noResults)\r\n          var results = new Array(resultsLen)\r\n          for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\r\n          results.total = resultsLen + limitedCount\r\n          resolve(results)\r\n        }\r\n\r\n        isNode?setImmediate(step):step() //setTimeout here is too slow\r\n      })\r\n      p.cancel = function() { canceled = true }\r\n      return p\r\n    },\r\n\r\n    highlight: function(result, hOpen, hClose) {\r\n      if(typeof hOpen == 'function') return fuzzysort.highlightCallback(result, hOpen)\r\n      if(result === null) return null\r\n      if(hOpen === undefined) hOpen = '<b>'\r\n      if(hClose === undefined) hClose = '</b>'\r\n      var highlighted = ''\r\n      var matchesIndex = 0\r\n      var opened = false\r\n      var target = result.target\r\n      var targetLen = target.length\r\n      var matchesBest = result.indexes\r\n      for(var i = 0; i < targetLen; ++i) { var char = target[i]\r\n        if(matchesBest[matchesIndex] === i) {\r\n          ++matchesIndex\r\n          if(!opened) { opened = true\r\n            highlighted += hOpen\r\n          }\r\n\r\n          if(matchesIndex === matchesBest.length) {\r\n            highlighted += char + hClose + target.substr(i+1)\r\n            break\r\n          }\r\n        } else {\r\n          if(opened) { opened = false\r\n            highlighted += hClose\r\n          }\r\n        }\r\n        highlighted += char\r\n      }\r\n\r\n      return highlighted\r\n    },\r\n    highlightCallback: function(result, cb) {\r\n      if(result === null) return null\r\n      var target = result.target\r\n      var targetLen = target.length\r\n      var indexes = result.indexes\r\n      var highlighted = ''\r\n      var matchI = 0\r\n      var indexesI = 0\r\n      var opened = false\r\n      var result = []\r\n      for(var i = 0; i < targetLen; ++i) { var char = target[i]\r\n        if(indexes[indexesI] === i) {\r\n          ++indexesI\r\n          if(!opened) { opened = true\r\n            result.push(highlighted); highlighted = ''\r\n          }\r\n\r\n          if(indexesI === indexes.length) {\r\n            highlighted += char\r\n            result.push(cb(highlighted, matchI++)); highlighted = ''\r\n            result.push(target.substr(i+1))\r\n            break\r\n          }\r\n        } else {\r\n          if(opened) { opened = false\r\n            result.push(cb(highlighted, matchI++)); highlighted = ''\r\n          }\r\n        }\r\n        highlighted += char\r\n      }\r\n      return result\r\n    },\r\n\r\n    prepare: function(target) {\r\n      if(!target) return {target: '', _targetLowerCodes: [0/*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/], _nextBeginningIndexes: null, score: null, indexes: null, obj: null} // hidden\r\n      return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:null, score:null, indexes:null, obj:null} // hidden\r\n    },\r\n    prepareSlow: function(target) {\r\n      if(!target) return {target: '', _targetLowerCodes: [0/*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/], _nextBeginningIndexes: null, score: null, indexes: null, obj: null} // hidden\r\n      return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:fuzzysort.prepareNextBeginningIndexes(target), score:null, indexes:null, obj:null} // hidden\r\n    },\r\n    prepareSearch: function(search) {\r\n      if(!search) search = ''\r\n      return fuzzysort.prepareLowerCodes(search)\r\n    },\r\n\r\n\r\n\r\n    // Below this point is only internal code\r\n    // Below this point is only internal code\r\n    // Below this point is only internal code\r\n    // Below this point is only internal code\r\n\r\n\r\n\r\n    getPrepared: function(target) {\r\n      if(target.length > 999) return fuzzysort.prepare(target) // don't cache huge targets\r\n      var targetPrepared = preparedCache.get(target)\r\n      if(targetPrepared !== undefined) return targetPrepared\r\n      targetPrepared = fuzzysort.prepare(target)\r\n      preparedCache.set(target, targetPrepared)\r\n      return targetPrepared\r\n    },\r\n    getPreparedSearch: function(search) {\r\n      if(search.length > 999) return fuzzysort.prepareSearch(search) // don't cache huge searches\r\n      var searchPrepared = preparedSearchCache.get(search)\r\n      if(searchPrepared !== undefined) return searchPrepared\r\n      searchPrepared = fuzzysort.prepareSearch(search)\r\n      preparedSearchCache.set(search, searchPrepared)\r\n      return searchPrepared\r\n    },\r\n\r\n    algorithm: function(searchLowerCodes, prepared, searchLowerCode) {\r\n      var targetLowerCodes = prepared._targetLowerCodes\r\n      var searchLen = searchLowerCodes.length\r\n      var targetLen = targetLowerCodes.length\r\n      var searchI = 0 // where we at\r\n      var targetI = 0 // where you at\r\n      var typoSimpleI = 0\r\n      var matchesSimpleLen = 0\r\n\r\n      // very basic fuzzy match; to remove non-matching targets ASAP!\r\n      // walk through target. find sequential matches.\r\n      // if all chars aren't found then exit\r\n      for(;;) {\r\n        var isMatch = searchLowerCode === targetLowerCodes[targetI]\r\n        if(isMatch) {\r\n          matchesSimple[matchesSimpleLen++] = targetI\r\n          ++searchI; if(searchI === searchLen) break\r\n          searchLowerCode = searchLowerCodes[typoSimpleI===0?searchI : (typoSimpleI===searchI?searchI+1 : (typoSimpleI===searchI-1?searchI-1 : searchI))]\r\n        }\r\n\r\n        ++targetI; if(targetI >= targetLen) { // Failed to find searchI\r\n          // Check for typo or exit\r\n          // we go as far as possible before trying to transpose\r\n          // then we transpose backwards until we reach the beginning\r\n          for(;;) {\r\n            if(searchI <= 1) return null // not allowed to transpose first char\r\n            if(typoSimpleI === 0) { // we haven't tried to transpose yet\r\n              --searchI\r\n              var searchLowerCodeNew = searchLowerCodes[searchI]\r\n              if(searchLowerCode === searchLowerCodeNew) continue // doesn't make sense to transpose a repeat char\r\n              typoSimpleI = searchI\r\n            } else {\r\n              if(typoSimpleI === 1) return null // reached the end of the line for transposing\r\n              --typoSimpleI\r\n              searchI = typoSimpleI\r\n              searchLowerCode = searchLowerCodes[searchI + 1]\r\n              var searchLowerCodeNew = searchLowerCodes[searchI]\r\n              if(searchLowerCode === searchLowerCodeNew) continue // doesn't make sense to transpose a repeat char\r\n            }\r\n            matchesSimpleLen = searchI\r\n            targetI = matchesSimple[matchesSimpleLen - 1] + 1\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      var searchI = 0\r\n      var typoStrictI = 0\r\n      var successStrict = false\r\n      var matchesStrictLen = 0\r\n\r\n      var nextBeginningIndexes = prepared._nextBeginningIndexes\r\n      if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target)\r\n      var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\r\n\r\n      // Our target string successfully matched all characters in sequence!\r\n      // Let's try a more advanced and strict test to improve the score\r\n      // only count it as a match if it's consecutive or a beginning character!\r\n      if(targetI !== targetLen) for(;;) {\r\n        if(targetI >= targetLen) {\r\n          // We failed to find a good spot for this search char, go back to the previous search char and force it forward\r\n          if(searchI <= 0) { // We failed to push chars forward for a better match\r\n            // transpose, starting from the beginning\r\n            ++typoStrictI; if(typoStrictI > searchLen-2) break\r\n            if(searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI+1]) continue // doesn't make sense to transpose a repeat char\r\n            targetI = firstPossibleI\r\n            continue\r\n          }\r\n\r\n          --searchI\r\n          var lastMatch = matchesStrict[--matchesStrictLen]\r\n          targetI = nextBeginningIndexes[lastMatch]\r\n\r\n        } else {\r\n          var isMatch = searchLowerCodes[typoStrictI===0?searchI : (typoStrictI===searchI?searchI+1 : (typoStrictI===searchI-1?searchI-1 : searchI))] === targetLowerCodes[targetI]\r\n          if(isMatch) {\r\n            matchesStrict[matchesStrictLen++] = targetI\r\n            ++searchI; if(searchI === searchLen) { successStrict = true; break }\r\n            ++targetI\r\n          } else {\r\n            targetI = nextBeginningIndexes[targetI]\r\n          }\r\n        }\r\n      }\r\n\r\n      { // tally up the score & keep track of matches for highlighting later\r\n        if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen }\r\n        else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen }\r\n        var score = 0\r\n        var lastTargetI = -1\r\n        for(var i = 0; i < searchLen; ++i) { var targetI = matchesBest[i]\r\n          // score only goes down if they're not consecutive\r\n          if(lastTargetI !== targetI - 1) score -= targetI\r\n          lastTargetI = targetI\r\n        }\r\n        if(!successStrict) {\r\n          score *= 1000\r\n          if(typoSimpleI !== 0) score += -20/*typoPenalty*/\r\n        } else {\r\n          if(typoStrictI !== 0) score += -20/*typoPenalty*/\r\n        }\r\n        score -= targetLen - searchLen\r\n        prepared.score = score\r\n        prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i]\r\n\r\n        return prepared\r\n      }\r\n    },\r\n\r\n    algorithmNoTypo: function(searchLowerCodes, prepared, searchLowerCode) {\r\n      var targetLowerCodes = prepared._targetLowerCodes\r\n      var searchLen = searchLowerCodes.length\r\n      var targetLen = targetLowerCodes.length\r\n      var searchI = 0 // where we at\r\n      var targetI = 0 // where you at\r\n      var matchesSimpleLen = 0\r\n\r\n      // very basic fuzzy match; to remove non-matching targets ASAP!\r\n      // walk through target. find sequential matches.\r\n      // if all chars aren't found then exit\r\n      for(;;) {\r\n        var isMatch = searchLowerCode === targetLowerCodes[targetI]\r\n        if(isMatch) {\r\n          matchesSimple[matchesSimpleLen++] = targetI\r\n          ++searchI; if(searchI === searchLen) break\r\n          searchLowerCode = searchLowerCodes[searchI]\r\n        }\r\n        ++targetI; if(targetI >= targetLen) return null // Failed to find searchI\r\n      }\r\n\r\n      var searchI = 0\r\n      var successStrict = false\r\n      var matchesStrictLen = 0\r\n\r\n      var nextBeginningIndexes = prepared._nextBeginningIndexes\r\n      if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target)\r\n      var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\r\n\r\n      // Our target string successfully matched all characters in sequence!\r\n      // Let's try a more advanced and strict test to improve the score\r\n      // only count it as a match if it's consecutive or a beginning character!\r\n      if(targetI !== targetLen) for(;;) {\r\n        if(targetI >= targetLen) {\r\n          // We failed to find a good spot for this search char, go back to the previous search char and force it forward\r\n          if(searchI <= 0) break // We failed to push chars forward for a better match\r\n\r\n          --searchI\r\n          var lastMatch = matchesStrict[--matchesStrictLen]\r\n          targetI = nextBeginningIndexes[lastMatch]\r\n\r\n        } else {\r\n          var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI]\r\n          if(isMatch) {\r\n            matchesStrict[matchesStrictLen++] = targetI\r\n            ++searchI; if(searchI === searchLen) { successStrict = true; break }\r\n            ++targetI\r\n          } else {\r\n            targetI = nextBeginningIndexes[targetI]\r\n          }\r\n        }\r\n      }\r\n\r\n      { // tally up the score & keep track of matches for highlighting later\r\n        if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen }\r\n        else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen }\r\n        var score = 0\r\n        var lastTargetI = -1\r\n        for(var i = 0; i < searchLen; ++i) { var targetI = matchesBest[i]\r\n          // score only goes down if they're not consecutive\r\n          if(lastTargetI !== targetI - 1) score -= targetI\r\n          lastTargetI = targetI\r\n        }\r\n        if(!successStrict) score *= 1000\r\n        score -= targetLen - searchLen\r\n        prepared.score = score\r\n        prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i]\r\n\r\n        return prepared\r\n      }\r\n    },\r\n\r\n    prepareLowerCodes: function(str) {\r\n      var strLen = str.length\r\n      var lowerCodes = [] // new Array(strLen)    sparse array is too slow\r\n      var lower = str.toLowerCase()\r\n      for(var i = 0; i < strLen; ++i) lowerCodes[i] = lower.charCodeAt(i)\r\n      return lowerCodes\r\n    },\r\n    prepareBeginningIndexes: function(target) {\r\n      var targetLen = target.length\r\n      var beginningIndexes = []; var beginningIndexesLen = 0\r\n      var wasUpper = false\r\n      var wasAlphanum = false\r\n      for(var i = 0; i < targetLen; ++i) {\r\n        var targetCode = target.charCodeAt(i)\r\n        var isUpper = targetCode>=65&&targetCode<=90\r\n        var isAlphanum = isUpper || targetCode>=97&&targetCode<=122 || targetCode>=48&&targetCode<=57\r\n        var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum\r\n        wasUpper = isUpper\r\n        wasAlphanum = isAlphanum\r\n        if(isBeginning) beginningIndexes[beginningIndexesLen++] = i\r\n      }\r\n      return beginningIndexes\r\n    },\r\n    prepareNextBeginningIndexes: function(target) {\r\n      var targetLen = target.length\r\n      var beginningIndexes = fuzzysort.prepareBeginningIndexes(target)\r\n      var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\r\n      var lastIsBeginning = beginningIndexes[0]\r\n      var lastIsBeginningI = 0\r\n      for(var i = 0; i < targetLen; ++i) {\r\n        if(lastIsBeginning > i) {\r\n          nextBeginningIndexes[i] = lastIsBeginning\r\n        } else {\r\n          lastIsBeginning = beginningIndexes[++lastIsBeginningI]\r\n          nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning\r\n        }\r\n      }\r\n      return nextBeginningIndexes\r\n    },\r\n\r\n    cleanup: cleanup,\r\n    new: fuzzysortNew,\r\n  }\r\n  return fuzzysort\r\n} // fuzzysortNew\r\n\r\n// This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\r\nvar isNode = typeof require !== 'undefined' && typeof window === 'undefined'\r\nvar MyMap = typeof Map === 'function' ? Map : function(){var s=Object.create(null);this.get=function(k){return s[k]};this.set=function(k,val){s[k]=val;return this};this.clear=function(){s=Object.create(null)}}\r\nvar preparedCache = new MyMap()\r\nvar preparedSearchCache = new MyMap()\r\nvar noResults = []; noResults.total = 0\r\nvar matchesSimple = []; var matchesStrict = []\r\nfunction cleanup() { preparedCache.clear(); preparedSearchCache.clear(); matchesSimple = []; matchesStrict = [] }\r\nfunction defaultScoreFn(a) {\r\n  var max = -9007199254740991\r\n  for (var i = a.length - 1; i >= 0; --i) {\r\n    var result = a[i]; if(result === null) continue\r\n    var score = result.score\r\n    if(score > max) max = score\r\n  }\r\n  if(max === -9007199254740991) return null\r\n  return max\r\n}\r\n\r\n// prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\r\n// prop = 'key1.key2'        10ms\r\n// prop = ['key1', 'key2']   27ms\r\nfunction getValue(obj, prop) {\r\n  var tmp = obj[prop]; if(tmp !== undefined) return tmp\r\n  var segs = prop\r\n  if(!Array.isArray(prop)) segs = prop.split('.')\r\n  var len = segs.length\r\n  var i = -1\r\n  while (obj && (++i < len)) obj = obj[segs[i]]\r\n  return obj\r\n}\r\n\r\nfunction isObj(x) { return typeof x === 'object' } // faster as a function\r\n\r\n// Hacked version of https://github.com/lemire/FastPriorityQueue.js\r\nvar fastpriorityqueue=function(){var r=[],o=0,e={};function n(){for(var e=0,n=r[e],c=1;c<o;){var f=c+1;e=c,f<o&&r[f].score<r[c].score&&(e=f),r[e-1>>1]=r[e],c=1+(e<<1)}for(var a=e-1>>1;e>0&&n.score<r[a].score;a=(e=a)-1>>1)r[e]=r[a];r[e]=n}return e.add=function(e){var n=o;r[o++]=e;for(var c=n-1>>1;n>0&&e.score<r[c].score;c=(n=c)-1>>1)r[n]=r[c];r[n]=e},e.poll=function(){if(0!==o){var e=r[0];return r[0]=r[--o],n(),e}},e.peek=function(e){if(0!==o)return r[0]},e.replaceTop=function(o){r[0]=o,n()},e};\r\nvar q = fastpriorityqueue() // reuse this, except for async, it needs to make its own\r\n\r\nreturn fuzzysortNew()\r\n}) // UMD\r\n\r\n// TODO: (performance) wasm version!?\r\n// TODO: (performance) threads?\r\n// TODO: (performance) avoid cache misses\r\n// TODO: (performance) preparedCache is a memory leak\r\n// TODO: (like sublime) backslash === forwardslash\r\n// TODO: (like sublime) spaces: \"a b\" should do 2 searches 1 for a and 1 for b\r\n// TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\r\n// TODO: (performance) idk if allowTypo is optimized\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAAC,CAAC,UAASA,IAAT,EAAeC,GAAf,EAAoB;EACpB,IAAG,OAAOC,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAA1C,EAA+CD,MAAM,CAAC,EAAD,EAAKD,GAAL,CAAN,CAA/C,KACK,IAAG,OAAOG,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,CAACC,OAAxC,EAAiDD,MAAM,CAACC,OAAP,GAAiBJ,GAAG,EAApB,CAAjD,KACAD,IAAI,CAACM,SAAL,GAAiBL,GAAG,EAApB;AACN,CAJA,EAIE,IAJF,EAIQ,SAASA,GAAT,GAAe;EAAE,SAASM,YAAT,CAAsBC,eAAtB,EAAuC;IAE/D,IAAIF,SAAS,GAAG;MAEdG,MAAM,EAAE,gBAASC,MAAT,EAAiBC,MAAjB,EAAyBC,OAAzB,EAAkC;QAAgN;QAAC,IAAGF,MAAM,IAAE,SAAX,EAAqB,OAAM;UAACC,MAAM,EAAC,0BAAR;UAAmCE,KAAK,EAAC,CAAzC;UAA2CC,OAAO,EAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb;QAAnD,CAAN;QAC9Q,IAAG,CAACJ,MAAJ,EAAY,OAAO,IAAP;QACZ,IAAG,CAACK,KAAK,CAACL,MAAD,CAAT,EAAmBA,MAAM,GAAGJ,SAAS,CAACU,iBAAV,CAA4BN,MAA5B,CAAT;QAEnB,IAAG,CAACC,MAAJ,EAAY,OAAO,IAAP;QACZ,IAAG,CAACI,KAAK,CAACJ,MAAD,CAAT,EAAmBA,MAAM,GAAGL,SAAS,CAACW,WAAV,CAAsBN,MAAtB,CAAT;QAEnB,IAAIO,SAAS,GAAGN,OAAO,IAAIA,OAAO,CAACM,SAAR,KAAoBC,SAA/B,GAA2CP,OAAO,CAACM,SAAnD,GACZV,eAAe,IAAIA,eAAe,CAACU,SAAhB,KAA4BC,SAA/C,GAA2DX,eAAe,CAACU,SAA3E,GACA,IAFJ;QAGA,IAAIE,SAAS,GAAGF,SAAS,GAAGZ,SAAS,CAACc,SAAb,GAAyBd,SAAS,CAACe,eAA5D;QACA,OAAOD,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBD,MAAM,CAAC,CAAD,CAAvB,CAAhB;MACD,CAda;MAgBdY,EAAE,EAAE,YAASZ,MAAT,EAAiBa,OAAjB,EAA0BX,OAA1B,EAAmC;QAAmN;QAAC,IAAGF,MAAM,IAAE,SAAX,EAAqB,OAAM,CAAC;UAACC,MAAM,EAAC,0BAAR;UAAmCE,KAAK,EAAC,CAAzC;UAA2CC,OAAO,EAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,CAAnD;UAAmEU,GAAG,EAACD,OAAO,GAACA,OAAO,CAAC,CAAD,CAAR,GAAY;QAA1F,CAAD,CAAN;QAC9Q,IAAG,CAACb,MAAJ,EAAY,OAAOe,SAAP;QACZf,MAAM,GAAGJ,SAAS,CAACoB,aAAV,CAAwBhB,MAAxB,CAAT;QACA,IAAIiB,eAAe,GAAGjB,MAAM,CAAC,CAAD,CAA5B;QAEA,IAAIkB,SAAS,GAAGhB,OAAO,IAAIA,OAAO,CAACgB,SAAnB,IAAgCpB,eAAe,IAAIA,eAAe,CAACoB,SAAnE,IAAgF,CAAC,gBAAjG;QACA,IAAIC,KAAK,GAAGjB,OAAO,IAAIA,OAAO,CAACiB,KAAnB,IAA4BrB,eAAe,IAAIA,eAAe,CAACqB,KAA/D,IAAwE,gBAApF;QACA,IAAIX,SAAS,GAAGN,OAAO,IAAIA,OAAO,CAACM,SAAR,KAAoBC,SAA/B,GAA2CP,OAAO,CAACM,SAAnD,GACZV,eAAe,IAAIA,eAAe,CAACU,SAAhB,KAA4BC,SAA/C,GAA2DX,eAAe,CAACU,SAA3E,GACA,IAFJ;QAGA,IAAIE,SAAS,GAAGF,SAAS,GAAGZ,SAAS,CAACc,SAAb,GAAyBd,SAAS,CAACe,eAA5D;QACA,IAAIS,UAAU,GAAG,CAAjB;QAAoB,IAAIC,YAAY,GAAG,CAAnB;QACpB,IAAIC,UAAU,GAAGT,OAAO,CAACU,MAAzB,CAZqC,CAcrC;QAEA;;QACA,IAAGrB,OAAO,IAAIA,OAAO,CAACsB,IAAtB,EAA4B;UAC1B,IAAIC,OAAO,GAAGvB,OAAO,CAACuB,OAAR,IAAmBC,cAAjC;UACA,IAAIF,IAAI,GAAGtB,OAAO,CAACsB,IAAnB;UACA,IAAIG,OAAO,GAAGH,IAAI,CAACD,MAAnB;;UACA,KAAI,IAAIK,CAAC,GAAGN,UAAU,GAAG,CAAzB,EAA4BM,CAAC,IAAI,CAAjC,EAAoC,EAAEA,CAAtC,EAAyC;YAAE,IAAId,GAAG,GAAGD,OAAO,CAACe,CAAD,CAAjB;YACzC,IAAIC,UAAU,GAAG,IAAIC,KAAJ,CAAUH,OAAV,CAAjB;;YACA,KAAK,IAAII,IAAI,GAAGJ,OAAO,GAAG,CAA1B,EAA6BI,IAAI,IAAI,CAArC,EAAwC,EAAEA,IAA1C,EAAgD;cAC9C,IAAIC,GAAG,GAAGR,IAAI,CAACO,IAAD,CAAd;cACA,IAAI9B,MAAM,GAAGgC,QAAQ,CAACnB,GAAD,EAAMkB,GAAN,CAArB;;cACA,IAAG,CAAC/B,MAAJ,EAAY;gBAAE4B,UAAU,CAACE,IAAD,CAAV,GAAmB,IAAnB;gBAAyB;cAAU;;cACjD,IAAG,CAAC1B,KAAK,CAACJ,MAAD,CAAT,EAAmBA,MAAM,GAAGL,SAAS,CAACW,WAAV,CAAsBN,MAAtB,CAAT;cAEnB4B,UAAU,CAACE,IAAD,CAAV,GAAmBrB,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBgB,eAAjB,CAA5B;YACD;;YACDY,UAAU,CAACf,GAAX,GAAiBA,GAAjB,CAVuC,CAUlB;;YACrB,IAAIX,KAAK,GAAGsB,OAAO,CAACI,UAAD,CAAnB;YACA,IAAG1B,KAAK,KAAK,IAAb,EAAmB;YACnB,IAAGA,KAAK,GAAGe,SAAX,EAAsB;YACtBW,UAAU,CAAC1B,KAAX,GAAmBA,KAAnB;;YACA,IAAGiB,UAAU,GAAGD,KAAhB,EAAuB;cAAEe,CAAC,CAACC,GAAF,CAAMN,UAAN;cAAmB,EAAET,UAAF;YAAc,CAA1D,MACK;cACH,EAAEC,YAAF;cACA,IAAGlB,KAAK,GAAG+B,CAAC,CAACE,IAAF,GAASjC,KAApB,EAA2B+B,CAAC,CAACG,UAAF,CAAaR,UAAb;YAC5B;UACF,CAxByB,CA0B5B;;QACC,CA3BD,MA2BO,IAAG3B,OAAO,IAAIA,OAAO,CAAC8B,GAAtB,EAA2B;UAChC,IAAIA,GAAG,GAAG9B,OAAO,CAAC8B,GAAlB;;UACA,KAAI,IAAIJ,CAAC,GAAGN,UAAU,GAAG,CAAzB,EAA4BM,CAAC,IAAI,CAAjC,EAAoC,EAAEA,CAAtC,EAAyC;YAAE,IAAId,GAAG,GAAGD,OAAO,CAACe,CAAD,CAAjB;YACzC,IAAI3B,MAAM,GAAGgC,QAAQ,CAACnB,GAAD,EAAMkB,GAAN,CAArB;YACA,IAAG,CAAC/B,MAAJ,EAAY;YACZ,IAAG,CAACI,KAAK,CAACJ,MAAD,CAAT,EAAmBA,MAAM,GAAGL,SAAS,CAACW,WAAV,CAAsBN,MAAtB,CAAT;YAEnB,IAAIqC,MAAM,GAAG5B,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBgB,eAAjB,CAAtB;YACA,IAAGqB,MAAM,KAAK,IAAd,EAAoB;YACpB,IAAGA,MAAM,CAACnC,KAAP,GAAee,SAAlB,EAA6B,SAPU,CASvC;;YACAoB,MAAM,GAAG;cAACrC,MAAM,EAACqC,MAAM,CAACrC,MAAf;cAAuBsC,iBAAiB,EAAC,IAAzC;cAA+CC,qBAAqB,EAAC,IAArE;cAA2ErC,KAAK,EAACmC,MAAM,CAACnC,KAAxF;cAA+FC,OAAO,EAACkC,MAAM,CAAClC,OAA9G;cAAuHU,GAAG,EAACA;YAA3H,CAAT,CAVuC,CAUkG;;YAEzI,IAAGM,UAAU,GAAGD,KAAhB,EAAuB;cAAEe,CAAC,CAACC,GAAF,CAAMG,MAAN;cAAe,EAAElB,UAAF;YAAc,CAAtD,MACK;cACH,EAAEC,YAAF;cACA,IAAGiB,MAAM,CAACnC,KAAP,GAAe+B,CAAC,CAACE,IAAF,GAASjC,KAA3B,EAAkC+B,CAAC,CAACG,UAAF,CAAaC,MAAb;YACnC;UACF,CAnB+B,CAqBlC;;QACC,CAtBM,MAsBA;UACL,KAAI,IAAIV,CAAC,GAAGN,UAAU,GAAG,CAAzB,EAA4BM,CAAC,IAAI,CAAjC,EAAoC,EAAEA,CAAtC,EAAyC;YAAE,IAAI3B,MAAM,GAAGY,OAAO,CAACe,CAAD,CAApB;YACzC,IAAG,CAAC3B,MAAJ,EAAY;YACZ,IAAG,CAACI,KAAK,CAACJ,MAAD,CAAT,EAAmBA,MAAM,GAAGL,SAAS,CAACW,WAAV,CAAsBN,MAAtB,CAAT;YAEnB,IAAIqC,MAAM,GAAG5B,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBgB,eAAjB,CAAtB;YACA,IAAGqB,MAAM,KAAK,IAAd,EAAoB;YACpB,IAAGA,MAAM,CAACnC,KAAP,GAAee,SAAlB,EAA6B;;YAC7B,IAAGE,UAAU,GAAGD,KAAhB,EAAuB;cAAEe,CAAC,CAACC,GAAF,CAAMG,MAAN;cAAe,EAAElB,UAAF;YAAc,CAAtD,MACK;cACH,EAAEC,YAAF;cACA,IAAGiB,MAAM,CAACnC,KAAP,GAAe+B,CAAC,CAACE,IAAF,GAASjC,KAA3B,EAAkC+B,CAAC,CAACG,UAAF,CAAaC,MAAb;YACnC;UACF;QACF;;QAED,IAAGlB,UAAU,KAAK,CAAlB,EAAqB,OAAOL,SAAP;QACrB,IAAI0B,OAAO,GAAG,IAAIX,KAAJ,CAAUV,UAAV,CAAd;;QACA,KAAI,IAAIQ,CAAC,GAAGR,UAAU,GAAG,CAAzB,EAA4BQ,CAAC,IAAI,CAAjC,EAAoC,EAAEA,CAAtC;UAAyCa,OAAO,CAACb,CAAD,CAAP,GAAaM,CAAC,CAACQ,IAAF,EAAb;QAAzC;;QACAD,OAAO,CAACE,KAAR,GAAgBvB,UAAU,GAAGC,YAA7B;QACA,OAAOoB,OAAP;MACD,CAvGa;MAyGdG,OAAO,EAAE,iBAAS5C,MAAT,EAAiBa,OAAjB,EAA0BX,OAA1B,EAAmC;QAC1C,IAAI2C,QAAQ,GAAG,KAAf;QACA,IAAIC,CAAC,GAAG,IAAIC,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;UAA0M;UAAC,IAAGjD,MAAM,IAAE,SAAX,EAAqB,OAAOgD,OAAO,CAAC,CAAC;YAAC/C,MAAM,EAAC,0BAAR;YAAmCE,KAAK,EAAC,CAAzC;YAA2CC,OAAO,EAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,CAAnD;YAAmEU,GAAG,EAACD,OAAO,GAACA,OAAO,CAAC,CAAD,CAAR,GAAY;UAA1F,CAAD,CAAD,CAAd;UAC5Q,IAAG,CAACb,MAAJ,EAAY,OAAOgD,OAAO,CAACjC,SAAD,CAAd;UACZf,MAAM,GAAGJ,SAAS,CAACoB,aAAV,CAAwBhB,MAAxB,CAAT;UACA,IAAIiB,eAAe,GAAGjB,MAAM,CAAC,CAAD,CAA5B;UAEA,IAAIkC,CAAC,GAAGgB,iBAAiB,EAAzB;UACA,IAAIC,QAAQ,GAAGtC,OAAO,CAACU,MAAR,GAAiB,CAAhC;UACA,IAAIL,SAAS,GAAGhB,OAAO,IAAIA,OAAO,CAACgB,SAAnB,IAAgCpB,eAAe,IAAIA,eAAe,CAACoB,SAAnE,IAAgF,CAAC,gBAAjG;UACA,IAAIC,KAAK,GAAGjB,OAAO,IAAIA,OAAO,CAACiB,KAAnB,IAA4BrB,eAAe,IAAIA,eAAe,CAACqB,KAA/D,IAAwE,gBAApF;UACA,IAAIX,SAAS,GAAGN,OAAO,IAAIA,OAAO,CAACM,SAAR,KAAoBC,SAA/B,GAA2CP,OAAO,CAACM,SAAnD,GACZV,eAAe,IAAIA,eAAe,CAACU,SAAhB,KAA4BC,SAA/C,GAA2DX,eAAe,CAACU,SAA3E,GACA,IAFJ;UAGA,IAAIE,SAAS,GAAGF,SAAS,GAAGZ,SAAS,CAACc,SAAb,GAAyBd,SAAS,CAACe,eAA5D;UACA,IAAIS,UAAU,GAAG,CAAjB;UAAoB,IAAIC,YAAY,GAAG,CAAnB;;UACpB,SAAS+B,IAAT,GAAgB;YACd,IAAGP,QAAH,EAAa,OAAOI,MAAM,CAAC,UAAD,CAAb;YAEb,IAAII,OAAO,GAAGC,IAAI,CAACC,GAAL,EAAd,CAHc,CAKd;YAEA;;YACA,IAAGrD,OAAO,IAAIA,OAAO,CAACsB,IAAtB,EAA4B;cAC1B,IAAIC,OAAO,GAAGvB,OAAO,CAACuB,OAAR,IAAmBC,cAAjC;cACA,IAAIF,IAAI,GAAGtB,OAAO,CAACsB,IAAnB;cACA,IAAIG,OAAO,GAAGH,IAAI,CAACD,MAAnB;;cACA,OAAM4B,QAAQ,IAAI,CAAlB,EAAqB,EAAEA,QAAvB,EAAiC;gBAC/B,IAAGA,QAAQ,GAAC;gBAAI;gBAAb,IAAmC,CAAtC,EAAyC;kBACvC,IAAGG,IAAI,CAACC,GAAL,KAAaF,OAAb,IAAwB;kBAAE;kBAA7B,EAAgD;oBAC9CG,MAAM,GAACC,YAAY,CAACL,IAAD,CAAb,GAAoBM,UAAU,CAACN,IAAD,CAApC;oBACA;kBACD;gBACF;;gBAED,IAAItC,GAAG,GAAGD,OAAO,CAACsC,QAAD,CAAjB;gBACA,IAAItB,UAAU,GAAG,IAAIC,KAAJ,CAAUH,OAAV,CAAjB;;gBACA,KAAK,IAAII,IAAI,GAAGJ,OAAO,GAAG,CAA1B,EAA6BI,IAAI,IAAI,CAArC,EAAwC,EAAEA,IAA1C,EAAgD;kBAC9C,IAAIC,GAAG,GAAGR,IAAI,CAACO,IAAD,CAAd;kBACA,IAAI9B,MAAM,GAAGgC,QAAQ,CAACnB,GAAD,EAAMkB,GAAN,CAArB;;kBACA,IAAG,CAAC/B,MAAJ,EAAY;oBAAE4B,UAAU,CAACE,IAAD,CAAV,GAAmB,IAAnB;oBAAyB;kBAAU;;kBACjD,IAAG,CAAC1B,KAAK,CAACJ,MAAD,CAAT,EAAmBA,MAAM,GAAGL,SAAS,CAACW,WAAV,CAAsBN,MAAtB,CAAT;kBAEnB4B,UAAU,CAACE,IAAD,CAAV,GAAmBrB,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBgB,eAAjB,CAA5B;gBACD;;gBACDY,UAAU,CAACf,GAAX,GAAiBA,GAAjB,CAlB+B,CAkBV;;gBACrB,IAAIX,KAAK,GAAGsB,OAAO,CAACI,UAAD,CAAnB;gBACA,IAAG1B,KAAK,KAAK,IAAb,EAAmB;gBACnB,IAAGA,KAAK,GAAGe,SAAX,EAAsB;gBACtBW,UAAU,CAAC1B,KAAX,GAAmBA,KAAnB;;gBACA,IAAGiB,UAAU,GAAGD,KAAhB,EAAuB;kBAAEe,CAAC,CAACC,GAAF,CAAMN,UAAN;kBAAmB,EAAET,UAAF;gBAAc,CAA1D,MACK;kBACH,EAAEC,YAAF;kBACA,IAAGlB,KAAK,GAAG+B,CAAC,CAACE,IAAF,GAASjC,KAApB,EAA2B+B,CAAC,CAACG,UAAF,CAAaR,UAAb;gBAC5B;cACF,CAhCyB,CAkC5B;;YACC,CAnCD,MAmCO,IAAG3B,OAAO,IAAIA,OAAO,CAAC8B,GAAtB,EAA2B;cAChC,IAAIA,GAAG,GAAG9B,OAAO,CAAC8B,GAAlB;;cACA,OAAMmB,QAAQ,IAAI,CAAlB,EAAqB,EAAEA,QAAvB,EAAiC;gBAC/B,IAAGA,QAAQ,GAAC;gBAAI;gBAAb,IAAmC,CAAtC,EAAyC;kBACvC,IAAGG,IAAI,CAACC,GAAL,KAAaF,OAAb,IAAwB;kBAAE;kBAA7B,EAAgD;oBAC9CG,MAAM,GAACC,YAAY,CAACL,IAAD,CAAb,GAAoBM,UAAU,CAACN,IAAD,CAApC;oBACA;kBACD;gBACF;;gBAED,IAAItC,GAAG,GAAGD,OAAO,CAACsC,QAAD,CAAjB;gBACA,IAAIlD,MAAM,GAAGgC,QAAQ,CAACnB,GAAD,EAAMkB,GAAN,CAArB;gBACA,IAAG,CAAC/B,MAAJ,EAAY;gBACZ,IAAG,CAACI,KAAK,CAACJ,MAAD,CAAT,EAAmBA,MAAM,GAAGL,SAAS,CAACW,WAAV,CAAsBN,MAAtB,CAAT;gBAEnB,IAAIqC,MAAM,GAAG5B,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBgB,eAAjB,CAAtB;gBACA,IAAGqB,MAAM,KAAK,IAAd,EAAoB;gBACpB,IAAGA,MAAM,CAACnC,KAAP,GAAee,SAAlB,EAA6B,SAfE,CAiB/B;;gBACAoB,MAAM,GAAG;kBAACrC,MAAM,EAACqC,MAAM,CAACrC,MAAf;kBAAuBsC,iBAAiB,EAAC,IAAzC;kBAA+CC,qBAAqB,EAAC,IAArE;kBAA2ErC,KAAK,EAACmC,MAAM,CAACnC,KAAxF;kBAA+FC,OAAO,EAACkC,MAAM,CAAClC,OAA9G;kBAAuHU,GAAG,EAACA;gBAA3H,CAAT,CAlB+B,CAkB0G;;gBAEzI,IAAGM,UAAU,GAAGD,KAAhB,EAAuB;kBAAEe,CAAC,CAACC,GAAF,CAAMG,MAAN;kBAAe,EAAElB,UAAF;gBAAc,CAAtD,MACK;kBACH,EAAEC,YAAF;kBACA,IAAGiB,MAAM,CAACnC,KAAP,GAAe+B,CAAC,CAACE,IAAF,GAASjC,KAA3B,EAAkC+B,CAAC,CAACG,UAAF,CAAaC,MAAb;gBACnC;cACF,CA3B+B,CA6BlC;;YACC,CA9BM,MA8BA;cACL,OAAMa,QAAQ,IAAI,CAAlB,EAAqB,EAAEA,QAAvB,EAAiC;gBAC/B,IAAGA,QAAQ,GAAC;gBAAI;gBAAb,IAAmC,CAAtC,EAAyC;kBACvC,IAAGG,IAAI,CAACC,GAAL,KAAaF,OAAb,IAAwB;kBAAE;kBAA7B,EAAgD;oBAC9CG,MAAM,GAACC,YAAY,CAACL,IAAD,CAAb,GAAoBM,UAAU,CAACN,IAAD,CAApC;oBACA;kBACD;gBACF;;gBAED,IAAInD,MAAM,GAAGY,OAAO,CAACsC,QAAD,CAApB;gBACA,IAAG,CAAClD,MAAJ,EAAY;gBACZ,IAAG,CAACI,KAAK,CAACJ,MAAD,CAAT,EAAmBA,MAAM,GAAGL,SAAS,CAACW,WAAV,CAAsBN,MAAtB,CAAT;gBAEnB,IAAIqC,MAAM,GAAG5B,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBgB,eAAjB,CAAtB;gBACA,IAAGqB,MAAM,KAAK,IAAd,EAAoB;gBACpB,IAAGA,MAAM,CAACnC,KAAP,GAAee,SAAlB,EAA6B;;gBAC7B,IAAGE,UAAU,GAAGD,KAAhB,EAAuB;kBAAEe,CAAC,CAACC,GAAF,CAAMG,MAAN;kBAAe,EAAElB,UAAF;gBAAc,CAAtD,MACK;kBACH,EAAEC,YAAF;kBACA,IAAGiB,MAAM,CAACnC,KAAP,GAAe+B,CAAC,CAACE,IAAF,GAASjC,KAA3B,EAAkC+B,CAAC,CAACG,UAAF,CAAaC,MAAb;gBACnC;cACF;YACF;;YAED,IAAGlB,UAAU,KAAK,CAAlB,EAAqB,OAAO4B,OAAO,CAACjC,SAAD,CAAd;YACrB,IAAI0B,OAAO,GAAG,IAAIX,KAAJ,CAAUV,UAAV,CAAd;;YACA,KAAI,IAAIQ,CAAC,GAAGR,UAAU,GAAG,CAAzB,EAA4BQ,CAAC,IAAI,CAAjC,EAAoC,EAAEA,CAAtC;cAAyCa,OAAO,CAACb,CAAD,CAAP,GAAaM,CAAC,CAACQ,IAAF,EAAb;YAAzC;;YACAD,OAAO,CAACE,KAAR,GAAgBvB,UAAU,GAAGC,YAA7B;YACA2B,OAAO,CAACP,OAAD,CAAP;UACD;;UAEDe,MAAM,GAACC,YAAY,CAACL,IAAD,CAAb,GAAoBA,IAAI,EAA9B,CAtH4C,CAsHX;QAClC,CAvHO,CAAR;;QAwHAN,CAAC,CAACa,MAAF,GAAW,YAAW;UAAEd,QAAQ,GAAG,IAAX;QAAiB,CAAzC;;QACA,OAAOC,CAAP;MACD,CArOa;MAuOdc,SAAS,EAAE,mBAAStB,MAAT,EAAiBuB,KAAjB,EAAwBC,MAAxB,EAAgC;QACzC,IAAG,OAAOD,KAAP,IAAgB,UAAnB,EAA+B,OAAOjE,SAAS,CAACmE,iBAAV,CAA4BzB,MAA5B,EAAoCuB,KAApC,CAAP;QAC/B,IAAGvB,MAAM,KAAK,IAAd,EAAoB,OAAO,IAAP;QACpB,IAAGuB,KAAK,KAAKpD,SAAb,EAAwBoD,KAAK,GAAG,KAAR;QACxB,IAAGC,MAAM,KAAKrD,SAAd,EAAyBqD,MAAM,GAAG,MAAT;QACzB,IAAIE,WAAW,GAAG,EAAlB;QACA,IAAIC,YAAY,GAAG,CAAnB;QACA,IAAIC,MAAM,GAAG,KAAb;QACA,IAAIjE,MAAM,GAAGqC,MAAM,CAACrC,MAApB;QACA,IAAIkE,SAAS,GAAGlE,MAAM,CAACsB,MAAvB;QACA,IAAI6C,WAAW,GAAG9B,MAAM,CAAClC,OAAzB;;QACA,KAAI,IAAIwB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGuC,SAAnB,EAA8B,EAAEvC,CAAhC,EAAmC;UAAE,IAAIyC,IAAI,GAAGpE,MAAM,CAAC2B,CAAD,CAAjB;;UACnC,IAAGwC,WAAW,CAACH,YAAD,CAAX,KAA8BrC,CAAjC,EAAoC;YAClC,EAAEqC,YAAF;;YACA,IAAG,CAACC,MAAJ,EAAY;cAAEA,MAAM,GAAG,IAAT;cACZF,WAAW,IAAIH,KAAf;YACD;;YAED,IAAGI,YAAY,KAAKG,WAAW,CAAC7C,MAAhC,EAAwC;cACtCyC,WAAW,IAAIK,IAAI,GAAGP,MAAP,GAAgB7D,MAAM,CAACqE,MAAP,CAAc1C,CAAC,GAAC,CAAhB,CAA/B;cACA;YACD;UACF,CAVD,MAUO;YACL,IAAGsC,MAAH,EAAW;cAAEA,MAAM,GAAG,KAAT;cACXF,WAAW,IAAIF,MAAf;YACD;UACF;;UACDE,WAAW,IAAIK,IAAf;QACD;;QAED,OAAOL,WAAP;MACD,CAtQa;MAuQdD,iBAAiB,EAAE,2BAASzB,MAAT,EAAiBiC,EAAjB,EAAqB;QACtC,IAAGjC,MAAM,KAAK,IAAd,EAAoB,OAAO,IAAP;QACpB,IAAIrC,MAAM,GAAGqC,MAAM,CAACrC,MAApB;QACA,IAAIkE,SAAS,GAAGlE,MAAM,CAACsB,MAAvB;QACA,IAAInB,OAAO,GAAGkC,MAAM,CAAClC,OAArB;QACA,IAAI4D,WAAW,GAAG,EAAlB;QACA,IAAIQ,MAAM,GAAG,CAAb;QACA,IAAIC,QAAQ,GAAG,CAAf;QACA,IAAIP,MAAM,GAAG,KAAb;QACA,IAAI5B,MAAM,GAAG,EAAb;;QACA,KAAI,IAAIV,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGuC,SAAnB,EAA8B,EAAEvC,CAAhC,EAAmC;UAAE,IAAIyC,IAAI,GAAGpE,MAAM,CAAC2B,CAAD,CAAjB;;UACnC,IAAGxB,OAAO,CAACqE,QAAD,CAAP,KAAsB7C,CAAzB,EAA4B;YAC1B,EAAE6C,QAAF;;YACA,IAAG,CAACP,MAAJ,EAAY;cAAEA,MAAM,GAAG,IAAT;cACZ5B,MAAM,CAACoC,IAAP,CAAYV,WAAZ;cAA0BA,WAAW,GAAG,EAAd;YAC3B;;YAED,IAAGS,QAAQ,KAAKrE,OAAO,CAACmB,MAAxB,EAAgC;cAC9ByC,WAAW,IAAIK,IAAf;cACA/B,MAAM,CAACoC,IAAP,CAAYH,EAAE,CAACP,WAAD,EAAcQ,MAAM,EAApB,CAAd;cAAwCR,WAAW,GAAG,EAAd;cACxC1B,MAAM,CAACoC,IAAP,CAAYzE,MAAM,CAACqE,MAAP,CAAc1C,CAAC,GAAC,CAAhB,CAAZ;cACA;YACD;UACF,CAZD,MAYO;YACL,IAAGsC,MAAH,EAAW;cAAEA,MAAM,GAAG,KAAT;cACX5B,MAAM,CAACoC,IAAP,CAAYH,EAAE,CAACP,WAAD,EAAcQ,MAAM,EAApB,CAAd;cAAwCR,WAAW,GAAG,EAAd;YACzC;UACF;;UACDA,WAAW,IAAIK,IAAf;QACD;;QACD,OAAO/B,MAAP;MACD,CAtSa;MAwSdqC,OAAO,EAAE,iBAAS1E,MAAT,EAAiB;QACxB,IAAG,CAACA,MAAJ,EAAY,OAAO;UAACA,MAAM,EAAE,EAAT;UAAasC,iBAAiB,EAAE,CAAC;UAAC;UAAF,CAAhC;UAAsJC,qBAAqB,EAAE,IAA7K;UAAmLrC,KAAK,EAAE,IAA1L;UAAgMC,OAAO,EAAE,IAAzM;UAA+MU,GAAG,EAAE;QAApN,CAAP,CADY,CACqN;;QAC7O,OAAO;UAACb,MAAM,EAACA,MAAR;UAAgBsC,iBAAiB,EAAC3C,SAAS,CAACgF,iBAAV,CAA4B3E,MAA5B,CAAlC;UAAuEuC,qBAAqB,EAAC,IAA7F;UAAmGrC,KAAK,EAAC,IAAzG;UAA+GC,OAAO,EAAC,IAAvH;UAA6HU,GAAG,EAAC;QAAjI,CAAP,CAFwB,CAEsH;MAC/I,CA3Sa;MA4Sd+D,WAAW,EAAE,qBAAS5E,MAAT,EAAiB;QAC5B,IAAG,CAACA,MAAJ,EAAY,OAAO;UAACA,MAAM,EAAE,EAAT;UAAasC,iBAAiB,EAAE,CAAC;UAAC;UAAF,CAAhC;UAAsJC,qBAAqB,EAAE,IAA7K;UAAmLrC,KAAK,EAAE,IAA1L;UAAgMC,OAAO,EAAE,IAAzM;UAA+MU,GAAG,EAAE;QAApN,CAAP,CADgB,CACiN;;QAC7O,OAAO;UAACb,MAAM,EAACA,MAAR;UAAgBsC,iBAAiB,EAAC3C,SAAS,CAACgF,iBAAV,CAA4B3E,MAA5B,CAAlC;UAAuEuC,qBAAqB,EAAC5C,SAAS,CAACkF,2BAAV,CAAsC7E,MAAtC,CAA7F;UAA4IE,KAAK,EAAC,IAAlJ;UAAwJC,OAAO,EAAC,IAAhK;UAAsKU,GAAG,EAAC;QAA1K,CAAP,CAF4B,CAE2J;MACxL,CA/Sa;MAgTdE,aAAa,EAAE,uBAAShB,MAAT,EAAiB;QAC9B,IAAG,CAACA,MAAJ,EAAYA,MAAM,GAAG,EAAT;QACZ,OAAOJ,SAAS,CAACgF,iBAAV,CAA4B5E,MAA5B,CAAP;MACD,CAnTa;MAuTd;MACA;MACA;MACA;MAIAO,WAAW,EAAE,qBAASN,MAAT,EAAiB;QAC5B,IAAGA,MAAM,CAACsB,MAAP,GAAgB,GAAnB,EAAwB,OAAO3B,SAAS,CAAC+E,OAAV,CAAkB1E,MAAlB,CAAP,CADI,CAC6B;;QACzD,IAAI8E,cAAc,GAAGC,aAAa,CAACC,GAAd,CAAkBhF,MAAlB,CAArB;QACA,IAAG8E,cAAc,KAAKtE,SAAtB,EAAiC,OAAOsE,cAAP;QACjCA,cAAc,GAAGnF,SAAS,CAAC+E,OAAV,CAAkB1E,MAAlB,CAAjB;QACA+E,aAAa,CAACE,GAAd,CAAkBjF,MAAlB,EAA0B8E,cAA1B;QACA,OAAOA,cAAP;MACD,CArUa;MAsUdzE,iBAAiB,EAAE,2BAASN,MAAT,EAAiB;QAClC,IAAGA,MAAM,CAACuB,MAAP,GAAgB,GAAnB,EAAwB,OAAO3B,SAAS,CAACoB,aAAV,CAAwBhB,MAAxB,CAAP,CADU,CAC6B;;QAC/D,IAAImF,cAAc,GAAGC,mBAAmB,CAACH,GAApB,CAAwBjF,MAAxB,CAArB;QACA,IAAGmF,cAAc,KAAK1E,SAAtB,EAAiC,OAAO0E,cAAP;QACjCA,cAAc,GAAGvF,SAAS,CAACoB,aAAV,CAAwBhB,MAAxB,CAAjB;QACAoF,mBAAmB,CAACF,GAApB,CAAwBlF,MAAxB,EAAgCmF,cAAhC;QACA,OAAOA,cAAP;MACD,CA7Ua;MA+UdzE,SAAS,EAAE,mBAAS2E,gBAAT,EAA2BC,QAA3B,EAAqCrE,eAArC,EAAsD;QAC/D,IAAIsE,gBAAgB,GAAGD,QAAQ,CAAC/C,iBAAhC;QACA,IAAIiD,SAAS,GAAGH,gBAAgB,CAAC9D,MAAjC;QACA,IAAI4C,SAAS,GAAGoB,gBAAgB,CAAChE,MAAjC;QACA,IAAIkE,OAAO,GAAG,CAAd,CAJ+D,CAI/C;;QAChB,IAAIC,OAAO,GAAG,CAAd,CAL+D,CAK/C;;QAChB,IAAIC,WAAW,GAAG,CAAlB;QACA,IAAIC,gBAAgB,GAAG,CAAvB,CAP+D,CAS/D;QACA;QACA;;QACA,SAAQ;UACN,IAAIC,OAAO,GAAG5E,eAAe,KAAKsE,gBAAgB,CAACG,OAAD,CAAlD;;UACA,IAAGG,OAAH,EAAY;YACVC,aAAa,CAACF,gBAAgB,EAAjB,CAAb,GAAoCF,OAApC;YACA,EAAED,OAAF;YAAW,IAAGA,OAAO,KAAKD,SAAf,EAA0B;YACrCvE,eAAe,GAAGoE,gBAAgB,CAACM,WAAW,KAAG,CAAd,GAAgBF,OAAhB,GAA2BE,WAAW,KAAGF,OAAd,GAAsBA,OAAO,GAAC,CAA9B,GAAmCE,WAAW,KAAGF,OAAO,GAAC,CAAtB,GAAwBA,OAAO,GAAC,CAAhC,GAAoCA,OAAnG,CAAlC;UACD;;UAED,EAAEC,OAAF;;UAAW,IAAGA,OAAO,IAAIvB,SAAd,EAAyB;YAAE;YACpC;YACA;YACA;YACA,SAAQ;cACN,IAAGsB,OAAO,IAAI,CAAd,EAAiB,OAAO,IAAP,CADX,CACuB;;cAC7B,IAAGE,WAAW,KAAK,CAAnB,EAAsB;gBAAE;gBACtB,EAAEF,OAAF;gBACA,IAAIM,kBAAkB,GAAGV,gBAAgB,CAACI,OAAD,CAAzC;gBACA,IAAGxE,eAAe,KAAK8E,kBAAvB,EAA2C,SAHvB,CAGgC;;gBACpDJ,WAAW,GAAGF,OAAd;cACD,CALD,MAKO;gBACL,IAAGE,WAAW,KAAK,CAAnB,EAAsB,OAAO,IAAP,CADjB,CAC6B;;gBAClC,EAAEA,WAAF;gBACAF,OAAO,GAAGE,WAAV;gBACA1E,eAAe,GAAGoE,gBAAgB,CAACI,OAAO,GAAG,CAAX,CAAlC;gBACA,IAAIM,kBAAkB,GAAGV,gBAAgB,CAACI,OAAD,CAAzC;gBACA,IAAGxE,eAAe,KAAK8E,kBAAvB,EAA2C,SANtC,CAM+C;cACrD;;cACDH,gBAAgB,GAAGH,OAAnB;cACAC,OAAO,GAAGI,aAAa,CAACF,gBAAgB,GAAG,CAApB,CAAb,GAAsC,CAAhD;cACA;YACD;UACF;QACF;;QAED,IAAIH,OAAO,GAAG,CAAd;QACA,IAAIO,WAAW,GAAG,CAAlB;QACA,IAAIC,aAAa,GAAG,KAApB;QACA,IAAIC,gBAAgB,GAAG,CAAvB;QAEA,IAAIC,oBAAoB,GAAGb,QAAQ,CAAC9C,qBAApC;QACA,IAAG2D,oBAAoB,KAAK,IAA5B,EAAkCA,oBAAoB,GAAGb,QAAQ,CAAC9C,qBAAT,GAAiC5C,SAAS,CAACkF,2BAAV,CAAsCQ,QAAQ,CAACrF,MAA/C,CAAxD;QAClC,IAAImG,cAAc,GAAGV,OAAO,GAAGI,aAAa,CAAC,CAAD,CAAb,KAAmB,CAAnB,GAAuB,CAAvB,GAA2BK,oBAAoB,CAACL,aAAa,CAAC,CAAD,CAAb,GAAiB,CAAlB,CAA9E,CArD+D,CAuD/D;QACA;QACA;;QACA,IAAGJ,OAAO,KAAKvB,SAAf,EAA0B,SAAQ;UAChC,IAAGuB,OAAO,IAAIvB,SAAd,EAAyB;YACvB;YACA,IAAGsB,OAAO,IAAI,CAAd,EAAiB;cAAE;cACjB;cACA,EAAEO,WAAF;cAAe,IAAGA,WAAW,GAAGR,SAAS,GAAC,CAA3B,EAA8B;cAC7C,IAAGH,gBAAgB,CAACW,WAAD,CAAhB,KAAkCX,gBAAgB,CAACW,WAAW,GAAC,CAAb,CAArD,EAAsE,SAHvD,CAGgE;;cAC/EN,OAAO,GAAGU,cAAV;cACA;YACD;;YAED,EAAEX,OAAF;YACA,IAAIY,SAAS,GAAGC,aAAa,CAAC,EAAEJ,gBAAH,CAA7B;YACAR,OAAO,GAAGS,oBAAoB,CAACE,SAAD,CAA9B;UAED,CAdD,MAcO;YACL,IAAIR,OAAO,GAAGR,gBAAgB,CAACW,WAAW,KAAG,CAAd,GAAgBP,OAAhB,GAA2BO,WAAW,KAAGP,OAAd,GAAsBA,OAAO,GAAC,CAA9B,GAAmCO,WAAW,KAAGP,OAAO,GAAC,CAAtB,GAAwBA,OAAO,GAAC,CAAhC,GAAoCA,OAAnG,CAAhB,KAAkIF,gBAAgB,CAACG,OAAD,CAAhK;;YACA,IAAGG,OAAH,EAAY;cACVS,aAAa,CAACJ,gBAAgB,EAAjB,CAAb,GAAoCR,OAApC;cACA,EAAED,OAAF;;cAAW,IAAGA,OAAO,KAAKD,SAAf,EAA0B;gBAAES,aAAa,GAAG,IAAhB;gBAAsB;cAAO;;cACpE,EAAEP,OAAF;YACD,CAJD,MAIO;cACLA,OAAO,GAAGS,oBAAoB,CAACT,OAAD,CAA9B;YACD;UACF;QACF;QAED;UAAE;UACA,IAAGO,aAAH,EAAkB;YAAE,IAAI7B,WAAW,GAAGkC,aAAlB;YAAiC,IAAIC,cAAc,GAAGL,gBAArB;UAAuC,CAA5F,MACK;YAAE,IAAI9B,WAAW,GAAG0B,aAAlB;YAAiC,IAAIS,cAAc,GAAGX,gBAArB;UAAuC;;UAC/E,IAAIzF,KAAK,GAAG,CAAZ;UACA,IAAIqG,WAAW,GAAG,CAAC,CAAnB;;UACA,KAAI,IAAI5E,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG4D,SAAnB,EAA8B,EAAE5D,CAAhC,EAAmC;YAAE,IAAI8D,OAAO,GAAGtB,WAAW,CAACxC,CAAD,CAAzB,CAAF,CACjC;;YACA,IAAG4E,WAAW,KAAKd,OAAO,GAAG,CAA7B,EAAgCvF,KAAK,IAAIuF,OAAT;YAChCc,WAAW,GAAGd,OAAd;UACD;;UACD,IAAG,CAACO,aAAJ,EAAmB;YACjB9F,KAAK,IAAI,IAAT;YACA,IAAGwF,WAAW,KAAK,CAAnB,EAAsBxF,KAAK,IAAI,CAAC,EAAV;YAAY;UACnC,CAHD,MAGO;YACL,IAAG6F,WAAW,KAAK,CAAnB,EAAsB7F,KAAK,IAAI,CAAC,EAAV;YAAY;UACnC;;UACDA,KAAK,IAAIgE,SAAS,GAAGqB,SAArB;UACAF,QAAQ,CAACnF,KAAT,GAAiBA,KAAjB;UACAmF,QAAQ,CAAClF,OAAT,GAAmB,IAAI0B,KAAJ,CAAUyE,cAAV,CAAnB;;UAA8C,KAAI,IAAI3E,CAAC,GAAG2E,cAAc,GAAG,CAA7B,EAAgC3E,CAAC,IAAI,CAArC,EAAwC,EAAEA,CAA1C;YAA6C0D,QAAQ,CAAClF,OAAT,CAAiBwB,CAAjB,IAAsBwC,WAAW,CAACxC,CAAD,CAAjC;UAA7C;;UAE9C,OAAO0D,QAAP;QACD;MACF,CA1ba;MA4bd3E,eAAe,EAAE,yBAAS0E,gBAAT,EAA2BC,QAA3B,EAAqCrE,eAArC,EAAsD;QACrE,IAAIsE,gBAAgB,GAAGD,QAAQ,CAAC/C,iBAAhC;QACA,IAAIiD,SAAS,GAAGH,gBAAgB,CAAC9D,MAAjC;QACA,IAAI4C,SAAS,GAAGoB,gBAAgB,CAAChE,MAAjC;QACA,IAAIkE,OAAO,GAAG,CAAd,CAJqE,CAIrD;;QAChB,IAAIC,OAAO,GAAG,CAAd,CALqE,CAKrD;;QAChB,IAAIE,gBAAgB,GAAG,CAAvB,CANqE,CAQrE;QACA;QACA;;QACA,SAAQ;UACN,IAAIC,OAAO,GAAG5E,eAAe,KAAKsE,gBAAgB,CAACG,OAAD,CAAlD;;UACA,IAAGG,OAAH,EAAY;YACVC,aAAa,CAACF,gBAAgB,EAAjB,CAAb,GAAoCF,OAApC;YACA,EAAED,OAAF;YAAW,IAAGA,OAAO,KAAKD,SAAf,EAA0B;YACrCvE,eAAe,GAAGoE,gBAAgB,CAACI,OAAD,CAAlC;UACD;;UACD,EAAEC,OAAF;UAAW,IAAGA,OAAO,IAAIvB,SAAd,EAAyB,OAAO,IAAP,CAP9B,CAO0C;QACjD;;QAED,IAAIsB,OAAO,GAAG,CAAd;QACA,IAAIQ,aAAa,GAAG,KAApB;QACA,IAAIC,gBAAgB,GAAG,CAAvB;QAEA,IAAIC,oBAAoB,GAAGb,QAAQ,CAAC9C,qBAApC;QACA,IAAG2D,oBAAoB,KAAK,IAA5B,EAAkCA,oBAAoB,GAAGb,QAAQ,CAAC9C,qBAAT,GAAiC5C,SAAS,CAACkF,2BAAV,CAAsCQ,QAAQ,CAACrF,MAA/C,CAAxD;QAClC,IAAImG,cAAc,GAAGV,OAAO,GAAGI,aAAa,CAAC,CAAD,CAAb,KAAmB,CAAnB,GAAuB,CAAvB,GAA2BK,oBAAoB,CAACL,aAAa,CAAC,CAAD,CAAb,GAAiB,CAAlB,CAA9E,CA3BqE,CA6BrE;QACA;QACA;;QACA,IAAGJ,OAAO,KAAKvB,SAAf,EAA0B,SAAQ;UAChC,IAAGuB,OAAO,IAAIvB,SAAd,EAAyB;YACvB;YACA,IAAGsB,OAAO,IAAI,CAAd,EAAiB,MAFM,CAEA;;YAEvB,EAAEA,OAAF;YACA,IAAIY,SAAS,GAAGC,aAAa,CAAC,EAAEJ,gBAAH,CAA7B;YACAR,OAAO,GAAGS,oBAAoB,CAACE,SAAD,CAA9B;UAED,CARD,MAQO;YACL,IAAIR,OAAO,GAAGR,gBAAgB,CAACI,OAAD,CAAhB,KAA8BF,gBAAgB,CAACG,OAAD,CAA5D;;YACA,IAAGG,OAAH,EAAY;cACVS,aAAa,CAACJ,gBAAgB,EAAjB,CAAb,GAAoCR,OAApC;cACA,EAAED,OAAF;;cAAW,IAAGA,OAAO,KAAKD,SAAf,EAA0B;gBAAES,aAAa,GAAG,IAAhB;gBAAsB;cAAO;;cACpE,EAAEP,OAAF;YACD,CAJD,MAIO;cACLA,OAAO,GAAGS,oBAAoB,CAACT,OAAD,CAA9B;YACD;UACF;QACF;QAED;UAAE;UACA,IAAGO,aAAH,EAAkB;YAAE,IAAI7B,WAAW,GAAGkC,aAAlB;YAAiC,IAAIC,cAAc,GAAGL,gBAArB;UAAuC,CAA5F,MACK;YAAE,IAAI9B,WAAW,GAAG0B,aAAlB;YAAiC,IAAIS,cAAc,GAAGX,gBAArB;UAAuC;;UAC/E,IAAIzF,KAAK,GAAG,CAAZ;UACA,IAAIqG,WAAW,GAAG,CAAC,CAAnB;;UACA,KAAI,IAAI5E,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG4D,SAAnB,EAA8B,EAAE5D,CAAhC,EAAmC;YAAE,IAAI8D,OAAO,GAAGtB,WAAW,CAACxC,CAAD,CAAzB,CAAF,CACjC;;YACA,IAAG4E,WAAW,KAAKd,OAAO,GAAG,CAA7B,EAAgCvF,KAAK,IAAIuF,OAAT;YAChCc,WAAW,GAAGd,OAAd;UACD;;UACD,IAAG,CAACO,aAAJ,EAAmB9F,KAAK,IAAI,IAAT;UACnBA,KAAK,IAAIgE,SAAS,GAAGqB,SAArB;UACAF,QAAQ,CAACnF,KAAT,GAAiBA,KAAjB;UACAmF,QAAQ,CAAClF,OAAT,GAAmB,IAAI0B,KAAJ,CAAUyE,cAAV,CAAnB;;UAA8C,KAAI,IAAI3E,CAAC,GAAG2E,cAAc,GAAG,CAA7B,EAAgC3E,CAAC,IAAI,CAArC,EAAwC,EAAEA,CAA1C;YAA6C0D,QAAQ,CAAClF,OAAT,CAAiBwB,CAAjB,IAAsBwC,WAAW,CAACxC,CAAD,CAAjC;UAA7C;;UAE9C,OAAO0D,QAAP;QACD;MACF,CAlgBa;MAogBdV,iBAAiB,EAAE,2BAAS6B,GAAT,EAAc;QAC/B,IAAIC,MAAM,GAAGD,GAAG,CAAClF,MAAjB;QACA,IAAIoF,UAAU,GAAG,EAAjB,CAF+B,CAEX;;QACpB,IAAIC,KAAK,GAAGH,GAAG,CAACI,WAAJ,EAAZ;;QACA,KAAI,IAAIjF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG8E,MAAnB,EAA2B,EAAE9E,CAA7B;UAAgC+E,UAAU,CAAC/E,CAAD,CAAV,GAAgBgF,KAAK,CAACE,UAAN,CAAiBlF,CAAjB,CAAhB;QAAhC;;QACA,OAAO+E,UAAP;MACD,CA1gBa;MA2gBdI,uBAAuB,EAAE,iCAAS9G,MAAT,EAAiB;QACxC,IAAIkE,SAAS,GAAGlE,MAAM,CAACsB,MAAvB;QACA,IAAIyF,gBAAgB,GAAG,EAAvB;QAA2B,IAAIC,mBAAmB,GAAG,CAA1B;QAC3B,IAAIC,QAAQ,GAAG,KAAf;QACA,IAAIC,WAAW,GAAG,KAAlB;;QACA,KAAI,IAAIvF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGuC,SAAnB,EAA8B,EAAEvC,CAAhC,EAAmC;UACjC,IAAIwF,UAAU,GAAGnH,MAAM,CAAC6G,UAAP,CAAkBlF,CAAlB,CAAjB;UACA,IAAIyF,OAAO,GAAGD,UAAU,IAAE,EAAZ,IAAgBA,UAAU,IAAE,EAA1C;UACA,IAAIE,UAAU,GAAGD,OAAO,IAAID,UAAU,IAAE,EAAZ,IAAgBA,UAAU,IAAE,GAAvC,IAA8CA,UAAU,IAAE,EAAZ,IAAgBA,UAAU,IAAE,EAA3F;UACA,IAAIG,WAAW,GAAGF,OAAO,IAAI,CAACH,QAAZ,IAAwB,CAACC,WAAzB,IAAwC,CAACG,UAA3D;UACAJ,QAAQ,GAAGG,OAAX;UACAF,WAAW,GAAGG,UAAd;UACA,IAAGC,WAAH,EAAgBP,gBAAgB,CAACC,mBAAmB,EAApB,CAAhB,GAA0CrF,CAA1C;QACjB;;QACD,OAAOoF,gBAAP;MACD,CA1hBa;MA2hBdlC,2BAA2B,EAAE,qCAAS7E,MAAT,EAAiB;QAC5C,IAAIkE,SAAS,GAAGlE,MAAM,CAACsB,MAAvB;QACA,IAAIyF,gBAAgB,GAAGpH,SAAS,CAACmH,uBAAV,CAAkC9G,MAAlC,CAAvB;QACA,IAAIkG,oBAAoB,GAAG,EAA3B,CAH4C,CAGd;;QAC9B,IAAIqB,eAAe,GAAGR,gBAAgB,CAAC,CAAD,CAAtC;QACA,IAAIS,gBAAgB,GAAG,CAAvB;;QACA,KAAI,IAAI7F,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGuC,SAAnB,EAA8B,EAAEvC,CAAhC,EAAmC;UACjC,IAAG4F,eAAe,GAAG5F,CAArB,EAAwB;YACtBuE,oBAAoB,CAACvE,CAAD,CAApB,GAA0B4F,eAA1B;UACD,CAFD,MAEO;YACLA,eAAe,GAAGR,gBAAgB,CAAC,EAAES,gBAAH,CAAlC;YACAtB,oBAAoB,CAACvE,CAAD,CAApB,GAA0B4F,eAAe,KAAG/G,SAAlB,GAA8B0D,SAA9B,GAA0CqD,eAApE;UACD;QACF;;QACD,OAAOrB,oBAAP;MACD,CA1iBa;MA4iBduB,OAAO,EAAEA,OA5iBK;MA6iBdC,GAAG,EAAE9H;IA7iBS,CAAhB;IA+iBA,OAAOD,SAAP;EACD,CAljBuB,CAkjBtB;EAEF;;;EACA,IAAI4D,MAAM,GAAG,OAAOoE,OAAP,KAAmB,WAAnB,IAAkC,OAAOC,MAAP,KAAkB,WAAjE;EACA,IAAIC,KAAK,GAAG,OAAOC,GAAP,KAAe,UAAf,GAA4BA,GAA5B,GAAkC,YAAU;IAAC,IAAIC,CAAC,GAACC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAN;;IAA0B,KAAKjD,GAAL,GAAS,UAASkD,CAAT,EAAW;MAAC,OAAOH,CAAC,CAACG,CAAD,CAAR;IAAY,CAAjC;;IAAkC,KAAKjD,GAAL,GAAS,UAASiD,CAAT,EAAWC,GAAX,EAAe;MAACJ,CAAC,CAACG,CAAD,CAAD,GAAKC,GAAL;MAAS,OAAO,IAAP;IAAY,CAA9C;;IAA+C,KAAKC,KAAL,GAAW,YAAU;MAACL,CAAC,GAACC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAF;IAAsB,CAA5C;EAA6C,CAAjN;EACA,IAAIlD,aAAa,GAAG,IAAI8C,KAAJ,EAApB;EACA,IAAI1C,mBAAmB,GAAG,IAAI0C,KAAJ,EAA1B;EACA,IAAI/G,SAAS,GAAG,EAAhB;EAAoBA,SAAS,CAAC4B,KAAV,GAAkB,CAAlB;EACpB,IAAImD,aAAa,GAAG,EAApB;EAAwB,IAAIQ,aAAa,GAAG,EAApB;;EACxB,SAASoB,OAAT,GAAmB;IAAE1C,aAAa,CAACqD,KAAd;IAAuBjD,mBAAmB,CAACiD,KAApB;IAA6BvC,aAAa,GAAG,EAAhB;IAAoBQ,aAAa,GAAG,EAAhB;EAAoB;;EACjH,SAAS5E,cAAT,CAAwB4G,CAAxB,EAA2B;IACzB,IAAIC,GAAG,GAAG,CAAC,gBAAX;;IACA,KAAK,IAAI3G,CAAC,GAAG0G,CAAC,CAAC/G,MAAF,GAAW,CAAxB,EAA2BK,CAAC,IAAI,CAAhC,EAAmC,EAAEA,CAArC,EAAwC;MACtC,IAAIU,MAAM,GAAGgG,CAAC,CAAC1G,CAAD,CAAd;MAAmB,IAAGU,MAAM,KAAK,IAAd,EAAoB;MACvC,IAAInC,KAAK,GAAGmC,MAAM,CAACnC,KAAnB;MACA,IAAGA,KAAK,GAAGoI,GAAX,EAAgBA,GAAG,GAAGpI,KAAN;IACjB;;IACD,IAAGoI,GAAG,KAAK,CAAC,gBAAZ,EAA8B,OAAO,IAAP;IAC9B,OAAOA,GAAP;EACD,CArkBuB,CAukBxB;EACA;EACA;;;EACA,SAAStG,QAAT,CAAkBnB,GAAlB,EAAuB0H,IAAvB,EAA6B;IAC3B,IAAIC,GAAG,GAAG3H,GAAG,CAAC0H,IAAD,CAAb;IAAqB,IAAGC,GAAG,KAAKhI,SAAX,EAAsB,OAAOgI,GAAP;IAC3C,IAAIC,IAAI,GAAGF,IAAX;IACA,IAAG,CAAC1G,KAAK,CAAC6G,OAAN,CAAcH,IAAd,CAAJ,EAAyBE,IAAI,GAAGF,IAAI,CAACI,KAAL,CAAW,GAAX,CAAP;IACzB,IAAIC,GAAG,GAAGH,IAAI,CAACnH,MAAf;IACA,IAAIK,CAAC,GAAG,CAAC,CAAT;;IACA,OAAOd,GAAG,IAAK,EAAEc,CAAF,GAAMiH,GAArB;MAA2B/H,GAAG,GAAGA,GAAG,CAAC4H,IAAI,CAAC9G,CAAD,CAAL,CAAT;IAA3B;;IACA,OAAOd,GAAP;EACD;;EAED,SAAST,KAAT,CAAeyI,CAAf,EAAkB;IAAE,OAAO,OAAOA,CAAP,KAAa,QAApB;EAA8B,CAplB1B,CAolB2B;EAEnD;;;EACA,IAAI5F,iBAAiB,GAAC,SAAlBA,iBAAkB,GAAU;IAAC,IAAI6F,CAAC,GAAC,EAAN;IAAA,IAASC,CAAC,GAAC,CAAX;IAAA,IAAaC,CAAC,GAAC,EAAf;;IAAkB,SAASC,CAAT,GAAY;MAAC,KAAI,IAAID,CAAC,GAAC,CAAN,EAAQC,CAAC,GAACH,CAAC,CAACE,CAAD,CAAX,EAAeE,CAAC,GAAC,CAArB,EAAuBA,CAAC,GAACH,CAAzB,GAA4B;QAAC,IAAII,CAAC,GAACD,CAAC,GAAC,CAAR;QAAUF,CAAC,GAACE,CAAF,EAAIC,CAAC,GAACJ,CAAF,IAAKD,CAAC,CAACK,CAAD,CAAD,CAAKjJ,KAAL,GAAW4I,CAAC,CAACI,CAAD,CAAD,CAAKhJ,KAArB,KAA6B8I,CAAC,GAACG,CAA/B,CAAJ,EAAsCL,CAAC,CAACE,CAAC,GAAC,CAAF,IAAK,CAAN,CAAD,GAAUF,CAAC,CAACE,CAAD,CAAjD,EAAqDE,CAAC,GAAC,KAAGF,CAAC,IAAE,CAAN,CAAvD;MAAgE;;MAAA,KAAI,IAAIX,CAAC,GAACW,CAAC,GAAC,CAAF,IAAK,CAAf,EAAiBA,CAAC,GAAC,CAAF,IAAKC,CAAC,CAAC/I,KAAF,GAAQ4I,CAAC,CAACT,CAAD,CAAD,CAAKnI,KAAnC,EAAyCmI,CAAC,GAAC,CAACW,CAAC,GAACX,CAAH,IAAM,CAAN,IAAS,CAApD;QAAsDS,CAAC,CAACE,CAAD,CAAD,GAAKF,CAAC,CAACT,CAAD,CAAN;MAAtD;;MAAgES,CAAC,CAACE,CAAD,CAAD,GAAKC,CAAL;IAAO;;IAAA,OAAOD,CAAC,CAAC9G,GAAF,GAAM,UAAS8G,CAAT,EAAW;MAAC,IAAIC,CAAC,GAACF,CAAN;MAAQD,CAAC,CAACC,CAAC,EAAF,CAAD,GAAOC,CAAP;;MAAS,KAAI,IAAIE,CAAC,GAACD,CAAC,GAAC,CAAF,IAAK,CAAf,EAAiBA,CAAC,GAAC,CAAF,IAAKD,CAAC,CAAC9I,KAAF,GAAQ4I,CAAC,CAACI,CAAD,CAAD,CAAKhJ,KAAnC,EAAyCgJ,CAAC,GAAC,CAACD,CAAC,GAACC,CAAH,IAAM,CAAN,IAAS,CAApD;QAAsDJ,CAAC,CAACG,CAAD,CAAD,GAAKH,CAAC,CAACI,CAAD,CAAN;MAAtD;;MAAgEJ,CAAC,CAACG,CAAD,CAAD,GAAKD,CAAL;IAAO,CAA1G,EAA2GA,CAAC,CAACvG,IAAF,GAAO,YAAU;MAAC,IAAG,MAAIsG,CAAP,EAAS;QAAC,IAAIC,CAAC,GAACF,CAAC,CAAC,CAAD,CAAP;QAAW,OAAOA,CAAC,CAAC,CAAD,CAAD,GAAKA,CAAC,CAAC,EAAEC,CAAH,CAAN,EAAYE,CAAC,EAAb,EAAgBD,CAAvB;MAAyB;IAAC,CAA5K,EAA6KA,CAAC,CAAC7G,IAAF,GAAO,UAAS6G,CAAT,EAAW;MAAC,IAAG,MAAID,CAAP,EAAS,OAAOD,CAAC,CAAC,CAAD,CAAR;IAAY,CAArN,EAAsNE,CAAC,CAAC5G,UAAF,GAAa,UAAS2G,CAAT,EAAW;MAACD,CAAC,CAAC,CAAD,CAAD,GAAKC,CAAL,EAAOE,CAAC,EAAR;IAAW,CAA1P,EAA2PD,CAAlQ;EAAoQ,CAAlf;;EACA,IAAI/G,CAAC,GAAGgB,iBAAiB,EAAzB,CAxlBwB,CAwlBI;;EAE5B,OAAOrD,YAAY,EAAnB;AACC,CA/lBA,E,CA+lBE;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script"}